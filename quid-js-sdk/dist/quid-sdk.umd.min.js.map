{"version":3,"file":"quid-sdk.umd.min.js","sources":["../src/core/extension-connector.ts","../src/core/webauthn-bridge.ts","../src/utils/event-emitter.ts","../src/utils/logger.ts","../src/core/quid-client.ts","../node_modules/jose/dist/browser/runtime/webcrypto.js","../node_modules/jose/dist/browser/lib/buffer_utils.js","../node_modules/jose/dist/browser/runtime/base64url.js","../node_modules/jose/dist/browser/util/errors.js","../node_modules/jose/dist/browser/lib/crypto_key.js","../node_modules/jose/dist/browser/lib/invalid_key_input.js","../node_modules/jose/dist/browser/runtime/is_key_like.js","../node_modules/jose/dist/browser/lib/is_object.js","../node_modules/jose/dist/browser/lib/is_jwk.js","../node_modules/jose/dist/browser/runtime/jwk_to_key.js","../node_modules/jose/dist/browser/runtime/normalize_key.js","../node_modules/jose/dist/browser/key/import.js","../node_modules/jose/dist/browser/lib/check_key_type.js","../node_modules/jose/dist/browser/runtime/verify.js","../node_modules/jose/dist/browser/runtime/get_sign_verify_key.js","../node_modules/jose/dist/browser/runtime/check_key_length.js","../node_modules/jose/dist/browser/runtime/subtle_dsa.js","../node_modules/jose/dist/browser/jws/flattened/verify.js","../node_modules/jose/dist/browser/lib/is_disjoint.js","../node_modules/jose/dist/browser/lib/validate_crit.js","../node_modules/jose/dist/browser/lib/validate_algorithms.js","../node_modules/jose/dist/browser/lib/secs.js","../node_modules/jose/dist/browser/lib/jwt_claims_set.js","../node_modules/jose/dist/browser/lib/epoch.js","../node_modules/jose/dist/browser/jwt/verify.js","../node_modules/jose/dist/browser/jws/compact/verify.js","../node_modules/jose/dist/browser/jwks/local.js","../node_modules/jose/dist/browser/jwks/remote.js","../node_modules/jose/dist/browser/runtime/fetch_jwks.js","../node_modules/jose/dist/browser/util/base64url.js","../src/components/signin-button.ts","../src/components/react/signin-button.tsx","../src/components/react/use-quid.ts","../src/index.ts","../src/oauth/oauth-client.ts","../node_modules/jose/dist/browser/util/decode_jwt.js"],"sourcesContent":["/**\n * Extension Connector\n * Handles communication with the QuID browser extension\n */\n\nimport {\n  QuIDConfig,\n  QuIDIdentity,\n  AuthenticationRequest,\n  AuthenticationResponse,\n  CreateIdentityRequest\n} from '../types';\nimport { Logger } from '../utils/logger';\n\nexport class ExtensionConnector {\n  private config: QuIDConfig;\n  private logger: Logger;\n  public isConnected = false;\n  private extensionId?: string;\n\n  constructor(config: QuIDConfig, logger: Logger) {\n    this.config = config;\n    this.logger = logger;\n  }\n\n  /**\n   * Attempt to connect to the QuID browser extension\n   */\n  public async connect(): Promise<boolean> {\n    try {\n      // Check if we're in a browser environment\n      if (typeof window === 'undefined' || !window.chrome?.runtime) {\n        this.logger.debug('Not in browser environment or Chrome APIs not available');\n        return false;\n      }\n\n      // Try to detect QuID extension\n      const detected = await this.detectExtension();\n      if (!detected) {\n        this.logger.debug('QuID extension not detected');\n        return false;\n      }\n\n      // Test connection\n      const status = await this.sendMessage({ type: 'GET_EXTENSION_STATUS' });\n      if (status && status.isConnected !== undefined) {\n        this.isConnected = true;\n        this.logger.info('Successfully connected to QuID extension');\n        return true;\n      }\n\n      return false;\n\n    } catch (error) {\n      this.logger.debug('Failed to connect to extension:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Disconnect from the extension\n   */\n  public disconnect(): void {\n    this.isConnected = false;\n    this.extensionId = undefined;\n  }\n\n  /**\n   * Get identities from the extension\n   */\n  public async getIdentities(): Promise<QuIDIdentity[]> {\n    if (!this.isConnected) {\n      throw new Error('Extension not connected');\n    }\n\n    try {\n      const response = await this.sendMessage({ type: 'GET_IDENTITIES' });\n      \n      if (response.success && response.identities) {\n        return response.identities.map(this.mapIdentity);\n      } else {\n        throw new Error(response.error || 'Failed to get identities');\n      }\n    } catch (error) {\n      this.logger.error('Failed to get identities from extension:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create a new identity via the extension\n   */\n  public async createIdentity(request: CreateIdentityRequest): Promise<QuIDIdentity> {\n    if (!this.isConnected) {\n      throw new Error('Extension not connected');\n    }\n\n    try {\n      const response = await this.sendMessage({\n        type: 'CREATE_IDENTITY',\n        config: {\n          name: request.name,\n          securityLevel: request.securityLevel || 'Level1',\n          networks: request.networks || ['web']\n        }\n      });\n\n      if (response.success && response.identity) {\n        return this.mapIdentity(response.identity);\n      } else {\n        throw new Error(response.error || 'Failed to create identity');\n      }\n    } catch (error) {\n      this.logger.error('Failed to create identity via extension:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Authenticate via the extension\n   */\n  public async authenticate(request: AuthenticationRequest): Promise<AuthenticationResponse> {\n    if (!this.isConnected) {\n      throw new Error('Extension not connected');\n    }\n\n    try {\n      const response = await this.sendMessage({\n        type: 'AUTH_REQUEST',\n        challenge: request.challenge,\n        allowCredentials: request.allowCredentials,\n        userVerification: request.userVerification,\n        timeout: request.timeout\n      });\n\n      return {\n        success: response.success || false,\n        error: response.error,\n        credential: response.credential,\n        identity: response.identity ? this.mapIdentity(response.identity) : undefined\n      };\n\n    } catch (error) {\n      this.logger.error('Authentication via extension failed:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Authentication failed'\n      };\n    }\n  }\n\n  /**\n   * Sign a challenge via the extension\n   */\n  public async signChallenge(identityId: string, challenge: string): Promise<string> {\n    if (!this.isConnected) {\n      throw new Error('Extension not connected');\n    }\n\n    try {\n      const response = await this.sendMessage({\n        type: 'SIGN_CHALLENGE',\n        identityId,\n        challenge,\n        origin: window.location.origin\n      });\n\n      if (response.success && response.signature) {\n        return response.signature;\n      } else {\n        throw new Error(response.error || 'Failed to sign challenge');\n      }\n    } catch (error) {\n      this.logger.error('Failed to sign challenge via extension:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Detect if QuID extension is installed\n   */\n  private async detectExtension(): Promise<boolean> {\n    try {\n      // Method 1: Check for QuID API in page\n      if (window.QuID && window.QuID.isAvailable) {\n        this.logger.debug('QuID API detected in page');\n        return true;\n      }\n\n      // Method 2: Check for extension via custom event\n      return new Promise((resolve) => {\n        const timeout = setTimeout(() => resolve(false), 1000);\n        \n        const handler = (event: CustomEvent) => {\n          if (event.detail && event.detail.available) {\n            clearTimeout(timeout);\n            window.removeEventListener('quid:ready', handler as EventListener);\n            resolve(true);\n          }\n        };\n\n        window.addEventListener('quid:ready', handler as EventListener);\n        \n        // Try to trigger extension detection\n        window.dispatchEvent(new CustomEvent('quid:detect'));\n      });\n\n    } catch (error) {\n      this.logger.debug('Extension detection failed:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Send message to extension\n   */\n  private async sendMessage(message: any): Promise<any> {\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Extension message timeout'));\n      }, this.config.timeout || 60000);\n\n      try {\n        // Method 1: Direct extension communication (if extension ID is known)\n        if (this.extensionId && window.chrome?.runtime) {\n          window.chrome.runtime.sendMessage(this.extensionId, message, (response) => {\n            clearTimeout(timeout);\n            if (window.chrome.runtime.lastError) {\n              reject(new Error(window.chrome.runtime.lastError.message));\n            } else {\n              resolve(response);\n            }\n          });\n          return;\n        }\n\n        // Method 2: Use QuID API if available\n        if (window.QuID) {\n          this.handleQuIDAPIMessage(message, resolve, reject, timeout);\n          return;\n        }\n\n        // Method 3: Custom events\n        this.handleCustomEventMessage(message, resolve, reject, timeout);\n\n      } catch (error) {\n        clearTimeout(timeout);\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Handle message via QuID API\n   */\n  private handleQuIDAPIMessage(message: any, resolve: Function, reject: Function, timeout: NodeJS.Timeout): void {\n    try {\n      switch (message.type) {\n        case 'GET_EXTENSION_STATUS':\n          window.QuID.isReady().then(resolve).catch(reject);\n          break;\n          \n        case 'GET_IDENTITIES':\n          window.QuID.getIdentities().then(resolve).catch(reject);\n          break;\n          \n        case 'AUTH_REQUEST':\n          window.QuID.authenticate({\n            challenge: message.challenge,\n            userVerification: message.userVerification,\n            timeout: message.timeout,\n            allowCredentials: message.allowCredentials\n          }).then(resolve).catch(reject);\n          break;\n          \n        case 'CREATE_IDENTITY':\n          window.QuID.createIdentity(message.config).then(resolve).catch(reject);\n          break;\n          \n        case 'SIGN_CHALLENGE':\n          window.QuID.signChallenge(message.identityId, message.challenge)\n            .then(signature => resolve({ success: true, signature }))\n            .catch(reject);\n          break;\n          \n        default:\n          reject(new Error('Unknown message type'));\n      }\n    } catch (error) {\n      clearTimeout(timeout);\n      reject(error);\n    }\n  }\n\n  /**\n   * Handle message via custom events\n   */\n  private handleCustomEventMessage(message: any, resolve: Function, reject: Function, timeout: NodeJS.Timeout): void {\n    const requestId = `quid-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    \n    const handler = (event: CustomEvent) => {\n      if (event.detail && event.detail.requestId === requestId) {\n        clearTimeout(timeout);\n        window.removeEventListener('quid:response', handler as EventListener);\n        resolve(event.detail.response);\n      }\n    };\n\n    window.addEventListener('quid:response', handler as EventListener);\n    \n    window.dispatchEvent(new CustomEvent('quid:request', {\n      detail: { ...message, requestId }\n    }));\n  }\n\n  /**\n   * Map extension identity to SDK identity\n   */\n  private mapIdentity(extIdentity: any): QuIDIdentity {\n    return {\n      id: extIdentity.id,\n      name: extIdentity.name,\n      securityLevel: extIdentity.security_level || extIdentity.securityLevel || 'Level1',\n      networks: extIdentity.networks || ['web'],\n      isActive: extIdentity.is_active !== false,\n      createdAt: new Date(extIdentity.created_at || extIdentity.createdAt || Date.now()),\n      lastUsedAt: extIdentity.last_used_at || extIdentity.lastUsedAt ? \n        new Date(extIdentity.last_used_at || extIdentity.lastUsedAt) : undefined,\n      publicKey: extIdentity.public_key || extIdentity.publicKey\n    };\n  }\n}\n\n// Extend window interface for QuID API\ndeclare global {\n  interface Window {\n    QuID?: {\n      isAvailable: boolean;\n      authenticate: (options: any) => Promise<any>;\n      getIdentities: () => Promise<any[]>;\n      createIdentity: (config: any) => Promise<any>;\n      signChallenge: (identityId: string, challenge: string) => Promise<string>;\n      isReady: () => Promise<any>;\n    };\n  }\n}","/**\n * WebAuthn Bridge\n * Provides fallback WebAuthn functionality when QuID extension is not available\n */\n\nimport {\n  AuthenticationRequest,\n  AuthenticationResponse,\n  WebAuthnCredentialRequestOptions,\n  QuIDCredential\n} from '../types';\nimport { Logger } from '../utils/logger';\n\nexport class WebAuthnBridge {\n  private logger: Logger;\n  private client: any; // Reference to QuIDClient\n\n  constructor(client: any, logger: Logger) {\n    this.client = client;\n    this.logger = logger;\n  }\n\n  /**\n   * Initialize WebAuthn bridge\n   */\n  public init(): void {\n    if (!this.isWebAuthnSupported()) {\n      this.logger.warn('WebAuthn is not supported in this browser');\n      return;\n    }\n\n    this.logger.debug('WebAuthn bridge initialized');\n  }\n\n  /**\n   * Check if WebAuthn is supported\n   */\n  public isWebAuthnSupported(): boolean {\n    return !!(navigator.credentials && navigator.credentials.create && navigator.credentials.get);\n  }\n\n  /**\n   * Authenticate using WebAuthn as fallback\n   */\n  public async authenticate(request: AuthenticationRequest): Promise<AuthenticationResponse> {\n    if (!this.isWebAuthnSupported()) {\n      return {\n        success: false,\n        error: 'WebAuthn is not supported in this browser'\n      };\n    }\n\n    try {\n      this.logger.debug('Starting WebAuthn fallback authentication');\n\n      const options: WebAuthnCredentialRequestOptions = {\n        publicKey: {\n          challenge: this.stringToArrayBuffer(request.challenge),\n          timeout: request.timeout,\n          rpId: request.rpId || this.extractDomain(request.origin),\n          allowCredentials: request.allowCredentials || [],\n          userVerification: request.userVerification || 'preferred'\n        }\n      };\n\n      const credential = await navigator.credentials.get(options) as PublicKeyCredential | null;\n\n      if (!credential) {\n        return {\n          success: false,\n          error: 'No credential returned from WebAuthn'\n        };\n      }\n\n      const response = credential.response as AuthenticatorAssertionResponse;\n      \n      const quidCredential: QuIDCredential = {\n        id: credential.id,\n        rawId: this.arrayBufferToString(credential.rawId),\n        type: 'public-key',\n        response: {\n          authenticatorData: this.arrayBufferToString(response.authenticatorData),\n          clientDataJSON: this.arrayBufferToString(response.clientDataJSON),\n          signature: this.arrayBufferToString(response.signature),\n          userHandle: response.userHandle ? this.arrayBufferToString(response.userHandle) : undefined\n        }\n      };\n\n      this.logger.info('WebAuthn fallback authentication successful');\n\n      return {\n        success: true,\n        credential: quidCredential\n      };\n\n    } catch (error) {\n      this.logger.error('WebAuthn fallback authentication failed:', error);\n      \n      return {\n        success: false,\n        error: this.getWebAuthnErrorMessage(error)\n      };\n    }\n  }\n\n  /**\n   * Create a WebAuthn credential (registration)\n   */\n  public async createCredential(options: {\n    challenge: string;\n    userId: string;\n    userName: string;\n    userDisplayName: string;\n    rpName: string;\n    rpId?: string;\n    timeout?: number;\n  }): Promise<AuthenticationResponse> {\n    if (!this.isWebAuthnSupported()) {\n      return {\n        success: false,\n        error: 'WebAuthn is not supported in this browser'\n      };\n    }\n\n    try {\n      this.logger.debug('Creating WebAuthn credential');\n\n      const createOptions: CredentialCreationOptions = {\n        publicKey: {\n          challenge: this.stringToArrayBuffer(options.challenge),\n          rp: {\n            name: options.rpName,\n            id: options.rpId || this.extractDomain(window.location.origin)\n          },\n          user: {\n            id: this.stringToArrayBuffer(options.userId),\n            name: options.userName,\n            displayName: options.userDisplayName\n          },\n          pubKeyCredParams: [\n            { alg: -7, type: 'public-key' }, // ES256\n            { alg: -257, type: 'public-key' } // RS256\n          ],\n          timeout: options.timeout || 60000,\n          authenticatorSelection: {\n            authenticatorAttachment: 'platform',\n            userVerification: 'preferred',\n            requireResidentKey: false\n          },\n          attestation: 'direct'\n        }\n      };\n\n      const credential = await navigator.credentials.create(createOptions) as PublicKeyCredential | null;\n\n      if (!credential) {\n        return {\n          success: false,\n          error: 'No credential created'\n        };\n      }\n\n      const response = credential.response as AuthenticatorAttestationResponse;\n      \n      const quidCredential: QuIDCredential = {\n        id: credential.id,\n        rawId: this.arrayBufferToString(credential.rawId),\n        type: 'public-key',\n        response: {\n          authenticatorData: this.arrayBufferToString(response.authenticatorData),\n          clientDataJSON: this.arrayBufferToString(response.clientDataJSON),\n          signature: '', // Not applicable for creation\n          userHandle: undefined\n        }\n      };\n\n      this.logger.info('WebAuthn credential created successfully');\n\n      return {\n        success: true,\n        credential: quidCredential\n      };\n\n    } catch (error) {\n      this.logger.error('WebAuthn credential creation failed:', error);\n      \n      return {\n        success: false,\n        error: this.getWebAuthnErrorMessage(error)\n      };\n    }\n  }\n\n  /**\n   * Check if a credential exists for the current origin\n   */\n  public async isCredentialAvailable(): Promise<boolean> {\n    if (!this.isWebAuthnSupported()) {\n      return false;\n    }\n\n    try {\n      // Try a simple get call with no allowCredentials to see if platform authenticator is available\n      const available = await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n      return available;\n    } catch (error) {\n      this.logger.debug('Could not check credential availability:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Cleanup WebAuthn bridge\n   */\n  public cleanup(): void {\n    // Nothing to cleanup for WebAuthn\n    this.logger.debug('WebAuthn bridge cleaned up');\n  }\n\n  /**\n   * Convert string to ArrayBuffer\n   */\n  private stringToArrayBuffer(str: string): ArrayBuffer {\n    // If it's already a hex string, convert from hex\n    if (/^[0-9a-fA-F]+$/.test(str)) {\n      const bytes = new Uint8Array(str.length / 2);\n      for (let i = 0; i < str.length; i += 2) {\n        bytes[i / 2] = parseInt(str.substr(i, 2), 16);\n      }\n      return bytes.buffer;\n    }\n    \n    // Otherwise, convert from UTF-8\n    const encoder = new TextEncoder();\n    return encoder.encode(str).buffer;\n  }\n\n  /**\n   * Convert ArrayBuffer to string\n   */\n  private arrayBufferToString(buffer: ArrayBuffer): string {\n    const bytes = new Uint8Array(buffer);\n    return Array.from(bytes, byte => byte.toString(16).padStart(2, '0')).join('');\n  }\n\n  /**\n   * Extract domain from origin\n   */\n  private extractDomain(origin: string): string {\n    try {\n      const url = new URL(origin);\n      return url.hostname;\n    } catch (error) {\n      this.logger.warn('Could not extract domain from origin:', origin);\n      return 'localhost';\n    }\n  }\n\n  /**\n   * Get user-friendly error message from WebAuthn error\n   */\n  private getWebAuthnErrorMessage(error: any): string {\n    if (!error) return 'Unknown WebAuthn error';\n\n    const errorName = error.name || '';\n    const errorMessage = error.message || '';\n\n    switch (errorName) {\n      case 'NotAllowedError':\n        return 'Authentication was cancelled or not allowed';\n      case 'SecurityError':\n        return 'Security error during authentication';\n      case 'NotSupportedError':\n        return 'WebAuthn is not supported on this device';\n      case 'InvalidStateError':\n        return 'Invalid state for WebAuthn operation';\n      case 'ConstraintError':\n        return 'WebAuthn constraints could not be satisfied';\n      case 'UnknownError':\n        return 'An unknown error occurred during authentication';\n      default:\n        return errorMessage || 'WebAuthn authentication failed';\n    }\n  }\n}","/**\n * Event Emitter\n * Simple type-safe event emitter for QuID SDK\n */\n\nexport type EventListener<T> = (event: T) => void;\n\nexport class EventEmitter<T> {\n  private listeners: EventListener<T>[] = [];\n\n  /**\n   * Add an event listener\n   */\n  public on(listener: EventListener<T>): () => void {\n    this.listeners.push(listener);\n    \n    // Return unsubscribe function\n    return () => {\n      const index = this.listeners.indexOf(listener);\n      if (index > -1) {\n        this.listeners.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * Add a one-time event listener\n   */\n  public once(listener: EventListener<T>): () => void {\n    const onceListener: EventListener<T> = (event: T) => {\n      listener(event);\n      unsubscribe();\n    };\n\n    const unsubscribe = this.on(onceListener);\n    return unsubscribe;\n  }\n\n  /**\n   * Emit an event to all listeners\n   */\n  public emit(event: T): void {\n    // Create a copy of listeners to avoid issues if listeners are modified during iteration\n    const currentListeners = [...this.listeners];\n    \n    for (const listener of currentListeners) {\n      try {\n        listener(event);\n      } catch (error) {\n        console.error('Error in event listener:', error);\n      }\n    }\n  }\n\n  /**\n   * Remove all listeners\n   */\n  public removeAllListeners(): void {\n    this.listeners = [];\n  }\n\n  /**\n   * Get the number of listeners\n   */\n  public get listenerCount(): number {\n    return this.listeners.length;\n  }\n}","/**\n * Logger\n * Simple logging utility for QuID SDK\n */\n\nexport class Logger {\n  private debug: boolean;\n  private prefix = '[QuID SDK]';\n\n  constructor(debug = false) {\n    this.debug = debug;\n  }\n\n  /**\n   * Set debug mode\n   */\n  public setDebug(debug: boolean): void {\n    this.debug = debug;\n  }\n\n  /**\n   * Log debug message (only in debug mode)\n   */\n  public debug(message: string, ...args: any[]): void {\n    if (this.debug) {\n      console.debug(this.prefix, message, ...args);\n    }\n  }\n\n  /**\n   * Log info message\n   */\n  public info(message: string, ...args: any[]): void {\n    if (this.debug) {\n      console.info(this.prefix, message, ...args);\n    }\n  }\n\n  /**\n   * Log warning message\n   */\n  public warn(message: string, ...args: any[]): void {\n    console.warn(this.prefix, message, ...args);\n  }\n\n  /**\n   * Log error message\n   */\n  public error(message: string, ...args: any[]): void {\n    console.error(this.prefix, message, ...args);\n  }\n}","/**\n * QuID Client\n * Core client for QuID authentication operations\n */\n\nimport {\n  QuIDConfig,\n  QuIDIdentity,\n  AuthenticationRequest,\n  AuthenticationResponse,\n  CreateIdentityRequest,\n  QuIDEvent,\n  QuIDEventType,\n  QuIDSDKError\n} from '../types';\nimport { ExtensionConnector } from './extension-connector';\nimport { WebAuthnBridge } from './webauthn-bridge';\nimport { EventEmitter } from '../utils/event-emitter';\nimport { Logger } from '../utils/logger';\n\nexport class QuIDClient extends EventEmitter<QuIDEvent> {\n  private config: Required<QuIDConfig>;\n  private extensionConnector: ExtensionConnector;\n  private webauthnBridge: WebAuthnBridge;\n  private logger: Logger;\n  private isReady = false;\n\n  constructor(config: QuIDConfig = {}) {\n    super();\n    \n    this.config = {\n      baseUrl: '',\n      timeout: 60000,\n      userVerification: 'preferred',\n      debug: false,\n      extensionId: '',\n      enableWebAuthnFallback: true,\n      ...config\n    };\n\n    this.logger = new Logger(this.config.debug);\n    this.extensionConnector = new ExtensionConnector(this.config, this.logger);\n    this.webauthnBridge = new WebAuthnBridge(this, this.logger);\n\n    this.init();\n  }\n\n  private async init(): Promise<void> {\n    try {\n      this.logger.debug('Initializing QuID client...');\n\n      // Try to connect to browser extension\n      const extensionConnected = await this.extensionConnector.connect();\n      \n      if (extensionConnected) {\n        this.logger.info('Connected to QuID browser extension');\n        this.emit({\n          type: 'extension-connected',\n          timestamp: new Date()\n        });\n      } else {\n        this.logger.warn('QuID browser extension not available');\n        \n        if (this.config.enableWebAuthnFallback) {\n          this.logger.info('WebAuthn fallback enabled');\n        }\n      }\n\n      // Set up WebAuthn integration\n      this.webauthnBridge.init();\n\n      this.isReady = true;\n      this.emit({\n        type: 'ready',\n        timestamp: new Date()\n      });\n\n      this.logger.info('QuID client ready');\n\n    } catch (error) {\n      this.logger.error('Failed to initialize QuID client:', error);\n      this.emit({\n        type: 'error',\n        data: error,\n        timestamp: new Date()\n      });\n    }\n  }\n\n  /**\n   * Check if QuID is ready for use\n   */\n  public get ready(): boolean {\n    return this.isReady;\n  }\n\n  /**\n   * Check if browser extension is available\n   */\n  public get extensionAvailable(): boolean {\n    return this.extensionConnector.isConnected;\n  }\n\n  /**\n   * Get available QuID identities\n   */\n  public async getIdentities(): Promise<QuIDIdentity[]> {\n    if (!this.isReady) {\n      throw this.createError('SDK_NOT_READY', 'QuID SDK is not ready');\n    }\n\n    try {\n      if (this.extensionConnector.isConnected) {\n        return await this.extensionConnector.getIdentities();\n      } else {\n        this.logger.warn('No extension available, returning empty identity list');\n        return [];\n      }\n    } catch (error) {\n      this.logger.error('Failed to get identities:', error);\n      throw this.createError('GET_IDENTITIES_FAILED', 'Failed to retrieve identities', error);\n    }\n  }\n\n  /**\n   * Create a new QuID identity\n   */\n  public async createIdentity(request: CreateIdentityRequest): Promise<QuIDIdentity> {\n    if (!this.isReady) {\n      throw this.createError('SDK_NOT_READY', 'QuID SDK is not ready');\n    }\n\n    if (!this.extensionConnector.isConnected) {\n      throw this.createError('EXTENSION_NOT_AVAILABLE', 'QuID browser extension is required for identity creation');\n    }\n\n    try {\n      this.logger.debug('Creating new identity:', request);\n      \n      const identity = await this.extensionConnector.createIdentity(request);\n      \n      this.emit({\n        type: 'identity-created',\n        data: identity,\n        timestamp: new Date()\n      });\n\n      this.logger.info('Identity created successfully:', identity.id);\n      return identity;\n\n    } catch (error) {\n      this.logger.error('Failed to create identity:', error);\n      throw this.createError('CREATE_IDENTITY_FAILED', 'Failed to create identity', error);\n    }\n  }\n\n  /**\n   * Authenticate using QuID\n   */\n  public async authenticate(request: Partial<AuthenticationRequest> = {}): Promise<AuthenticationResponse> {\n    if (!this.isReady) {\n      throw this.createError('SDK_NOT_READY', 'QuID SDK is not ready');\n    }\n\n    const authRequest: AuthenticationRequest = {\n      challenge: request.challenge || this.generateChallenge(),\n      origin: request.origin || window.location.origin,\n      userVerification: request.userVerification || this.config.userVerification,\n      timeout: request.timeout || this.config.timeout,\n      allowCredentials: request.allowCredentials,\n      rpId: request.rpId\n    };\n\n    this.emit({\n      type: 'authentication-started',\n      data: authRequest,\n      timestamp: new Date()\n    });\n\n    try {\n      this.logger.debug('Starting authentication:', authRequest);\n\n      let response: AuthenticationResponse;\n\n      if (this.extensionConnector.isConnected) {\n        // Use QuID extension\n        response = await this.extensionConnector.authenticate(authRequest);\n      } else if (this.config.enableWebAuthnFallback && navigator.credentials) {\n        // Fallback to WebAuthn\n        this.logger.info('Using WebAuthn fallback');\n        response = await this.webauthnBridge.authenticate(authRequest);\n      } else {\n        throw this.createError('NO_AUTH_METHOD', 'No authentication method available');\n      }\n\n      if (response.success) {\n        this.emit({\n          type: 'authentication-completed',\n          data: response,\n          timestamp: new Date()\n        });\n        this.logger.info('Authentication successful');\n      } else {\n        this.emit({\n          type: 'authentication-failed',\n          data: response,\n          timestamp: new Date()\n        });\n        this.logger.warn('Authentication failed:', response.error);\n      }\n\n      return response;\n\n    } catch (error) {\n      this.logger.error('Authentication error:', error);\n      \n      const errorResponse: AuthenticationResponse = {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown authentication error'\n      };\n\n      this.emit({\n        type: 'authentication-failed',\n        data: errorResponse,\n        timestamp: new Date()\n      });\n\n      return errorResponse;\n    }\n  }\n\n  /**\n   * Sign a challenge with a specific identity\n   */\n  public async signChallenge(identityId: string, challenge: string): Promise<string> {\n    if (!this.isReady) {\n      throw this.createError('SDK_NOT_READY', 'QuID SDK is not ready');\n    }\n\n    if (!this.extensionConnector.isConnected) {\n      throw this.createError('EXTENSION_NOT_AVAILABLE', 'QuID browser extension is required for signing');\n    }\n\n    try {\n      this.logger.debug('Signing challenge:', { identityId, challenge });\n      \n      const signature = await this.extensionConnector.signChallenge(identityId, challenge);\n      \n      this.logger.info('Challenge signed successfully');\n      return signature;\n\n    } catch (error) {\n      this.logger.error('Failed to sign challenge:', error);\n      throw this.createError('SIGN_CHALLENGE_FAILED', 'Failed to sign challenge', error);\n    }\n  }\n\n  /**\n   * Check connection status\n   */\n  public async getStatus(): Promise<{\n    ready: boolean;\n    extensionAvailable: boolean;\n    identityCount: number;\n    version: string;\n  }> {\n    const identities = this.extensionAvailable ? await this.getIdentities() : [];\n    \n    return {\n      ready: this.isReady,\n      extensionAvailable: this.extensionAvailable,\n      identityCount: identities.length,\n      version: '1.0.0'\n    };\n  }\n\n  /**\n   * Update configuration\n   */\n  public updateConfig(newConfig: Partial<QuIDConfig>): void {\n    Object.assign(this.config, newConfig);\n    this.logger.setDebug(this.config.debug);\n    this.logger.debug('Configuration updated:', newConfig);\n  }\n\n  /**\n   * Disconnect and cleanup\n   */\n  public disconnect(): void {\n    this.logger.debug('Disconnecting QuID client');\n    \n    this.extensionConnector.disconnect();\n    this.webauthnBridge.cleanup();\n    this.isReady = false;\n    \n    this.emit({\n      type: 'extension-disconnected',\n      timestamp: new Date()\n    });\n  }\n\n  private generateChallenge(): string {\n    const array = new Uint8Array(32);\n    crypto.getRandomValues(array);\n    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');\n  }\n\n  private createError(code: string, message: string, cause?: any): QuIDSDKError {\n    const error = new Error(message) as QuIDSDKError;\n    error.name = 'QuIDSDKError';\n    error.code = code;\n    error.details = cause;\n    return error;\n  }\n}","export default crypto;\nexport const isCryptoKey = (key) => key instanceof CryptoKey;\n","import digest from '../runtime/digest.js';\nexport const encoder = new TextEncoder();\nexport const decoder = new TextDecoder();\nconst MAX_INT32 = 2 ** 32;\nexport function concat(...buffers) {\n    const size = buffers.reduce((acc, { length }) => acc + length, 0);\n    const buf = new Uint8Array(size);\n    let i = 0;\n    for (const buffer of buffers) {\n        buf.set(buffer, i);\n        i += buffer.length;\n    }\n    return buf;\n}\nexport function p2s(alg, p2sInput) {\n    return concat(encoder.encode(alg), new Uint8Array([0]), p2sInput);\n}\nfunction writeUInt32BE(buf, value, offset) {\n    if (value < 0 || value >= MAX_INT32) {\n        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);\n    }\n    buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);\n}\nexport function uint64be(value) {\n    const high = Math.floor(value / MAX_INT32);\n    const low = value % MAX_INT32;\n    const buf = new Uint8Array(8);\n    writeUInt32BE(buf, high, 0);\n    writeUInt32BE(buf, low, 4);\n    return buf;\n}\nexport function uint32be(value) {\n    const buf = new Uint8Array(4);\n    writeUInt32BE(buf, value);\n    return buf;\n}\nexport function lengthAndInput(input) {\n    return concat(uint32be(input.length), input);\n}\nexport async function concatKdf(secret, bits, value) {\n    const iterations = Math.ceil((bits >> 3) / 32);\n    const res = new Uint8Array(iterations * 32);\n    for (let iter = 0; iter < iterations; iter++) {\n        const buf = new Uint8Array(4 + secret.length + value.length);\n        buf.set(uint32be(iter + 1));\n        buf.set(secret, 4);\n        buf.set(value, 4 + secret.length);\n        res.set(await digest('sha256', buf), iter * 32);\n    }\n    return res.slice(0, bits >> 3);\n}\n","import { encoder, decoder } from '../lib/buffer_utils.js';\nexport const encodeBase64 = (input) => {\n    let unencoded = input;\n    if (typeof unencoded === 'string') {\n        unencoded = encoder.encode(unencoded);\n    }\n    const CHUNK_SIZE = 0x8000;\n    const arr = [];\n    for (let i = 0; i < unencoded.length; i += CHUNK_SIZE) {\n        arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));\n    }\n    return btoa(arr.join(''));\n};\nexport const encode = (input) => {\n    return encodeBase64(input).replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n};\nexport const decodeBase64 = (encoded) => {\n    const binary = atob(encoded);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n};\nexport const decode = (input) => {\n    let encoded = input;\n    if (encoded instanceof Uint8Array) {\n        encoded = decoder.decode(encoded);\n    }\n    encoded = encoded.replace(/-/g, '+').replace(/_/g, '/').replace(/\\s/g, '');\n    try {\n        return decodeBase64(encoded);\n    }\n    catch {\n        throw new TypeError('The input to be decoded is not correctly encoded.');\n    }\n};\n","export class JOSEError extends Error {\n    constructor(message, options) {\n        super(message, options);\n        this.code = 'ERR_JOSE_GENERIC';\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nJOSEError.code = 'ERR_JOSE_GENERIC';\nexport class JWTClaimValidationFailed extends JOSEError {\n    constructor(message, payload, claim = 'unspecified', reason = 'unspecified') {\n        super(message, { cause: { claim, reason, payload } });\n        this.code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n        this.claim = claim;\n        this.reason = reason;\n        this.payload = payload;\n    }\n}\nJWTClaimValidationFailed.code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\nexport class JWTExpired extends JOSEError {\n    constructor(message, payload, claim = 'unspecified', reason = 'unspecified') {\n        super(message, { cause: { claim, reason, payload } });\n        this.code = 'ERR_JWT_EXPIRED';\n        this.claim = claim;\n        this.reason = reason;\n        this.payload = payload;\n    }\n}\nJWTExpired.code = 'ERR_JWT_EXPIRED';\nexport class JOSEAlgNotAllowed extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n    }\n}\nJOSEAlgNotAllowed.code = 'ERR_JOSE_ALG_NOT_ALLOWED';\nexport class JOSENotSupported extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JOSE_NOT_SUPPORTED';\n    }\n}\nJOSENotSupported.code = 'ERR_JOSE_NOT_SUPPORTED';\nexport class JWEDecryptionFailed extends JOSEError {\n    constructor(message = 'decryption operation failed', options) {\n        super(message, options);\n        this.code = 'ERR_JWE_DECRYPTION_FAILED';\n    }\n}\nJWEDecryptionFailed.code = 'ERR_JWE_DECRYPTION_FAILED';\nexport class JWEInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWE_INVALID';\n    }\n}\nJWEInvalid.code = 'ERR_JWE_INVALID';\nexport class JWSInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWS_INVALID';\n    }\n}\nJWSInvalid.code = 'ERR_JWS_INVALID';\nexport class JWTInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWT_INVALID';\n    }\n}\nJWTInvalid.code = 'ERR_JWT_INVALID';\nexport class JWKInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWK_INVALID';\n    }\n}\nJWKInvalid.code = 'ERR_JWK_INVALID';\nexport class JWKSInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_INVALID';\n    }\n}\nJWKSInvalid.code = 'ERR_JWKS_INVALID';\nexport class JWKSNoMatchingKey extends JOSEError {\n    constructor(message = 'no applicable key found in the JSON Web Key Set', options) {\n        super(message, options);\n        this.code = 'ERR_JWKS_NO_MATCHING_KEY';\n    }\n}\nJWKSNoMatchingKey.code = 'ERR_JWKS_NO_MATCHING_KEY';\nexport class JWKSMultipleMatchingKeys extends JOSEError {\n    constructor(message = 'multiple matching keys found in the JSON Web Key Set', options) {\n        super(message, options);\n        this.code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    }\n}\nSymbol.asyncIterator;\nJWKSMultipleMatchingKeys.code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\nexport class JWKSTimeout extends JOSEError {\n    constructor(message = 'request timed out', options) {\n        super(message, options);\n        this.code = 'ERR_JWKS_TIMEOUT';\n    }\n}\nJWKSTimeout.code = 'ERR_JWKS_TIMEOUT';\nexport class JWSSignatureVerificationFailed extends JOSEError {\n    constructor(message = 'signature verification failed', options) {\n        super(message, options);\n        this.code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    }\n}\nJWSSignatureVerificationFailed.code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n","function unusable(name, prop = 'algorithm.name') {\n    return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);\n}\nfunction isAlgorithm(algorithm, name) {\n    return algorithm.name === name;\n}\nfunction getHashLength(hash) {\n    return parseInt(hash.name.slice(4), 10);\n}\nfunction getNamedCurve(alg) {\n    switch (alg) {\n        case 'ES256':\n            return 'P-256';\n        case 'ES384':\n            return 'P-384';\n        case 'ES512':\n            return 'P-521';\n        default:\n            throw new Error('unreachable');\n    }\n}\nfunction checkUsage(key, usages) {\n    if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {\n        let msg = 'CryptoKey does not support this operation, its usages must include ';\n        if (usages.length > 2) {\n            const last = usages.pop();\n            msg += `one of ${usages.join(', ')}, or ${last}.`;\n        }\n        else if (usages.length === 2) {\n            msg += `one of ${usages[0]} or ${usages[1]}.`;\n        }\n        else {\n            msg += `${usages[0]}.`;\n        }\n        throw new TypeError(msg);\n    }\n}\nexport function checkSigCryptoKey(key, alg, ...usages) {\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512': {\n            if (!isAlgorithm(key.algorithm, 'HMAC'))\n                throw unusable('HMAC');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'RS256':\n        case 'RS384':\n        case 'RS512': {\n            if (!isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5'))\n                throw unusable('RSASSA-PKCS1-v1_5');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'PS256':\n        case 'PS384':\n        case 'PS512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-PSS'))\n                throw unusable('RSA-PSS');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'EdDSA': {\n            if (key.algorithm.name !== 'Ed25519' && key.algorithm.name !== 'Ed448') {\n                throw unusable('Ed25519 or Ed448');\n            }\n            break;\n        }\n        case 'Ed25519': {\n            if (!isAlgorithm(key.algorithm, 'Ed25519'))\n                throw unusable('Ed25519');\n            break;\n        }\n        case 'ES256':\n        case 'ES384':\n        case 'ES512': {\n            if (!isAlgorithm(key.algorithm, 'ECDSA'))\n                throw unusable('ECDSA');\n            const expected = getNamedCurve(alg);\n            const actual = key.algorithm.namedCurve;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.namedCurve');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usages);\n}\nexport function checkEncCryptoKey(key, alg, ...usages) {\n    switch (alg) {\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM': {\n            if (!isAlgorithm(key.algorithm, 'AES-GCM'))\n                throw unusable('AES-GCM');\n            const expected = parseInt(alg.slice(1, 4), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            if (!isAlgorithm(key.algorithm, 'AES-KW'))\n                throw unusable('AES-KW');\n            const expected = parseInt(alg.slice(1, 4), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'ECDH': {\n            switch (key.algorithm.name) {\n                case 'ECDH':\n                case 'X25519':\n                case 'X448':\n                    break;\n                default:\n                    throw unusable('ECDH, X25519, or X448');\n            }\n            break;\n        }\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW':\n            if (!isAlgorithm(key.algorithm, 'PBKDF2'))\n                throw unusable('PBKDF2');\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-OAEP'))\n                throw unusable('RSA-OAEP');\n            const expected = parseInt(alg.slice(9), 10) || 1;\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usages);\n}\n","function message(msg, actual, ...types) {\n    types = types.filter(Boolean);\n    if (types.length > 2) {\n        const last = types.pop();\n        msg += `one of type ${types.join(', ')}, or ${last}.`;\n    }\n    else if (types.length === 2) {\n        msg += `one of type ${types[0]} or ${types[1]}.`;\n    }\n    else {\n        msg += `of type ${types[0]}.`;\n    }\n    if (actual == null) {\n        msg += ` Received ${actual}`;\n    }\n    else if (typeof actual === 'function' && actual.name) {\n        msg += ` Received function ${actual.name}`;\n    }\n    else if (typeof actual === 'object' && actual != null) {\n        if (actual.constructor?.name) {\n            msg += ` Received an instance of ${actual.constructor.name}`;\n        }\n    }\n    return msg;\n}\nexport default (actual, ...types) => {\n    return message('Key must be ', actual, ...types);\n};\nexport function withAlg(alg, actual, ...types) {\n    return message(`Key for the ${alg} algorithm must be `, actual, ...types);\n}\n","import { isCryptoKey } from './webcrypto.js';\nexport default (key) => {\n    if (isCryptoKey(key)) {\n        return true;\n    }\n    return key?.[Symbol.toStringTag] === 'KeyObject';\n};\nexport const types = ['CryptoKey'];\n","function isObjectLike(value) {\n    return typeof value === 'object' && value !== null;\n}\nexport default function isObject(input) {\n    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {\n        return false;\n    }\n    if (Object.getPrototypeOf(input) === null) {\n        return true;\n    }\n    let proto = input;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(input) === proto;\n}\n","import isObject from './is_object.js';\nexport function isJWK(key) {\n    return isObject(key) && typeof key.kty === 'string';\n}\nexport function isPrivateJWK(key) {\n    return key.kty !== 'oct' && typeof key.d === 'string';\n}\nexport function isPublicJWK(key) {\n    return key.kty !== 'oct' && typeof key.d === 'undefined';\n}\nexport function isSecretJWK(key) {\n    return isJWK(key) && key.kty === 'oct' && typeof key.k === 'string';\n}\n","import crypto from './webcrypto.js';\nimport { JOSENotSupported } from '../util/errors.js';\nfunction subtleMapping(jwk) {\n    let algorithm;\n    let keyUsages;\n    switch (jwk.kty) {\n        case 'RSA': {\n            switch (jwk.alg) {\n                case 'PS256':\n                case 'PS384':\n                case 'PS512':\n                    algorithm = { name: 'RSA-PSS', hash: `SHA-${jwk.alg.slice(-3)}` };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'RS256':\n                case 'RS384':\n                case 'RS512':\n                    algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${jwk.alg.slice(-3)}` };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'RSA-OAEP':\n                case 'RSA-OAEP-256':\n                case 'RSA-OAEP-384':\n                case 'RSA-OAEP-512':\n                    algorithm = {\n                        name: 'RSA-OAEP',\n                        hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`,\n                    };\n                    keyUsages = jwk.d ? ['decrypt', 'unwrapKey'] : ['encrypt', 'wrapKey'];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'EC': {\n            switch (jwk.alg) {\n                case 'ES256':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-256' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ES384':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-384' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ES512':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-521' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ECDH-ES':\n                case 'ECDH-ES+A128KW':\n                case 'ECDH-ES+A192KW':\n                case 'ECDH-ES+A256KW':\n                    algorithm = { name: 'ECDH', namedCurve: jwk.crv };\n                    keyUsages = jwk.d ? ['deriveBits'] : [];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'OKP': {\n            switch (jwk.alg) {\n                case 'Ed25519':\n                    algorithm = { name: 'Ed25519' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'EdDSA':\n                    algorithm = { name: jwk.crv };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ECDH-ES':\n                case 'ECDH-ES+A128KW':\n                case 'ECDH-ES+A192KW':\n                case 'ECDH-ES+A256KW':\n                    algorithm = { name: jwk.crv };\n                    keyUsages = jwk.d ? ['deriveBits'] : [];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        default:\n            throw new JOSENotSupported('Invalid or unsupported JWK \"kty\" (Key Type) Parameter value');\n    }\n    return { algorithm, keyUsages };\n}\nconst parse = async (jwk) => {\n    if (!jwk.alg) {\n        throw new TypeError('\"alg\" argument is required when \"jwk.alg\" is not present');\n    }\n    const { algorithm, keyUsages } = subtleMapping(jwk);\n    const rest = [\n        algorithm,\n        jwk.ext ?? false,\n        jwk.key_ops ?? keyUsages,\n    ];\n    const keyData = { ...jwk };\n    delete keyData.alg;\n    delete keyData.use;\n    return crypto.subtle.importKey('jwk', keyData, ...rest);\n};\nexport default parse;\n","import { isJWK } from '../lib/is_jwk.js';\nimport { decode } from './base64url.js';\nimport importJWK from './jwk_to_key.js';\nconst exportKeyValue = (k) => decode(k);\nlet privCache;\nlet pubCache;\nconst isKeyObject = (key) => {\n    return key?.[Symbol.toStringTag] === 'KeyObject';\n};\nconst importAndCache = async (cache, key, jwk, alg, freeze = false) => {\n    let cached = cache.get(key);\n    if (cached?.[alg]) {\n        return cached[alg];\n    }\n    const cryptoKey = await importJWK({ ...jwk, alg });\n    if (freeze)\n        Object.freeze(key);\n    if (!cached) {\n        cache.set(key, { [alg]: cryptoKey });\n    }\n    else {\n        cached[alg] = cryptoKey;\n    }\n    return cryptoKey;\n};\nconst normalizePublicKey = (key, alg) => {\n    if (isKeyObject(key)) {\n        let jwk = key.export({ format: 'jwk' });\n        delete jwk.d;\n        delete jwk.dp;\n        delete jwk.dq;\n        delete jwk.p;\n        delete jwk.q;\n        delete jwk.qi;\n        if (jwk.k) {\n            return exportKeyValue(jwk.k);\n        }\n        pubCache || (pubCache = new WeakMap());\n        return importAndCache(pubCache, key, jwk, alg);\n    }\n    if (isJWK(key)) {\n        if (key.k)\n            return decode(key.k);\n        pubCache || (pubCache = new WeakMap());\n        const cryptoKey = importAndCache(pubCache, key, key, alg, true);\n        return cryptoKey;\n    }\n    return key;\n};\nconst normalizePrivateKey = (key, alg) => {\n    if (isKeyObject(key)) {\n        let jwk = key.export({ format: 'jwk' });\n        if (jwk.k) {\n            return exportKeyValue(jwk.k);\n        }\n        privCache || (privCache = new WeakMap());\n        return importAndCache(privCache, key, jwk, alg);\n    }\n    if (isJWK(key)) {\n        if (key.k)\n            return decode(key.k);\n        privCache || (privCache = new WeakMap());\n        const cryptoKey = importAndCache(privCache, key, key, alg, true);\n        return cryptoKey;\n    }\n    return key;\n};\nexport default { normalizePublicKey, normalizePrivateKey };\n","import { decode as decodeBase64URL } from '../runtime/base64url.js';\nimport { fromSPKI, fromPKCS8, fromX509 } from '../runtime/asn1.js';\nimport asKeyObject from '../runtime/jwk_to_key.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport isObject from '../lib/is_object.js';\nexport async function importSPKI(spki, alg, options) {\n    if (typeof spki !== 'string' || spki.indexOf('-----BEGIN PUBLIC KEY-----') !== 0) {\n        throw new TypeError('\"spki\" must be SPKI formatted string');\n    }\n    return fromSPKI(spki, alg, options);\n}\nexport async function importX509(x509, alg, options) {\n    if (typeof x509 !== 'string' || x509.indexOf('-----BEGIN CERTIFICATE-----') !== 0) {\n        throw new TypeError('\"x509\" must be X.509 formatted string');\n    }\n    return fromX509(x509, alg, options);\n}\nexport async function importPKCS8(pkcs8, alg, options) {\n    if (typeof pkcs8 !== 'string' || pkcs8.indexOf('-----BEGIN PRIVATE KEY-----') !== 0) {\n        throw new TypeError('\"pkcs8\" must be PKCS#8 formatted string');\n    }\n    return fromPKCS8(pkcs8, alg, options);\n}\nexport async function importJWK(jwk, alg) {\n    if (!isObject(jwk)) {\n        throw new TypeError('JWK must be an object');\n    }\n    alg || (alg = jwk.alg);\n    switch (jwk.kty) {\n        case 'oct':\n            if (typeof jwk.k !== 'string' || !jwk.k) {\n                throw new TypeError('missing \"k\" (Key Value) Parameter value');\n            }\n            return decodeBase64URL(jwk.k);\n        case 'RSA':\n            if ('oth' in jwk && jwk.oth !== undefined) {\n                throw new JOSENotSupported('RSA JWK \"oth\" (Other Primes Info) Parameter value is not supported');\n            }\n        case 'EC':\n        case 'OKP':\n            return asKeyObject({ ...jwk, alg });\n        default:\n            throw new JOSENotSupported('Unsupported \"kty\" (Key Type) Parameter value');\n    }\n}\n","import { withAlg as invalidKeyInput } from './invalid_key_input.js';\nimport isKeyLike, { types } from '../runtime/is_key_like.js';\nimport * as jwk from './is_jwk.js';\nconst tag = (key) => key?.[Symbol.toStringTag];\nconst jwkMatchesOp = (alg, key, usage) => {\n    if (key.use !== undefined && key.use !== 'sig') {\n        throw new TypeError('Invalid key for this operation, when present its use must be sig');\n    }\n    if (key.key_ops !== undefined && key.key_ops.includes?.(usage) !== true) {\n        throw new TypeError(`Invalid key for this operation, when present its key_ops must include ${usage}`);\n    }\n    if (key.alg !== undefined && key.alg !== alg) {\n        throw new TypeError(`Invalid key for this operation, when present its alg must be ${alg}`);\n    }\n    return true;\n};\nconst symmetricTypeCheck = (alg, key, usage, allowJwk) => {\n    if (key instanceof Uint8Array)\n        return;\n    if (allowJwk && jwk.isJWK(key)) {\n        if (jwk.isSecretJWK(key) && jwkMatchesOp(alg, key, usage))\n            return;\n        throw new TypeError(`JSON Web Key for symmetric algorithms must have JWK \"kty\" (Key Type) equal to \"oct\" and the JWK \"k\" (Key Value) present`);\n    }\n    if (!isKeyLike(key)) {\n        throw new TypeError(invalidKeyInput(alg, key, ...types, 'Uint8Array', allowJwk ? 'JSON Web Key' : null));\n    }\n    if (key.type !== 'secret') {\n        throw new TypeError(`${tag(key)} instances for symmetric algorithms must be of type \"secret\"`);\n    }\n};\nconst asymmetricTypeCheck = (alg, key, usage, allowJwk) => {\n    if (allowJwk && jwk.isJWK(key)) {\n        switch (usage) {\n            case 'sign':\n                if (jwk.isPrivateJWK(key) && jwkMatchesOp(alg, key, usage))\n                    return;\n                throw new TypeError(`JSON Web Key for this operation be a private JWK`);\n            case 'verify':\n                if (jwk.isPublicJWK(key) && jwkMatchesOp(alg, key, usage))\n                    return;\n                throw new TypeError(`JSON Web Key for this operation be a public JWK`);\n        }\n    }\n    if (!isKeyLike(key)) {\n        throw new TypeError(invalidKeyInput(alg, key, ...types, allowJwk ? 'JSON Web Key' : null));\n    }\n    if (key.type === 'secret') {\n        throw new TypeError(`${tag(key)} instances for asymmetric algorithms must not be of type \"secret\"`);\n    }\n    if (usage === 'sign' && key.type === 'public') {\n        throw new TypeError(`${tag(key)} instances for asymmetric algorithm signing must be of type \"private\"`);\n    }\n    if (usage === 'decrypt' && key.type === 'public') {\n        throw new TypeError(`${tag(key)} instances for asymmetric algorithm decryption must be of type \"private\"`);\n    }\n    if (key.algorithm && usage === 'verify' && key.type === 'private') {\n        throw new TypeError(`${tag(key)} instances for asymmetric algorithm verifying must be of type \"public\"`);\n    }\n    if (key.algorithm && usage === 'encrypt' && key.type === 'private') {\n        throw new TypeError(`${tag(key)} instances for asymmetric algorithm encryption must be of type \"public\"`);\n    }\n};\nfunction checkKeyType(allowJwk, alg, key, usage) {\n    const symmetric = alg.startsWith('HS') ||\n        alg === 'dir' ||\n        alg.startsWith('PBES2') ||\n        /^A\\d{3}(?:GCM)?KW$/.test(alg);\n    if (symmetric) {\n        symmetricTypeCheck(alg, key, usage, allowJwk);\n    }\n    else {\n        asymmetricTypeCheck(alg, key, usage, allowJwk);\n    }\n}\nexport default checkKeyType.bind(undefined, false);\nexport const checkKeyTypeWithJwk = checkKeyType.bind(undefined, true);\n","import subtleAlgorithm from './subtle_dsa.js';\nimport crypto from './webcrypto.js';\nimport checkKeyLength from './check_key_length.js';\nimport getVerifyKey from './get_sign_verify_key.js';\nconst verify = async (alg, key, signature, data) => {\n    const cryptoKey = await getVerifyKey(alg, key, 'verify');\n    checkKeyLength(alg, cryptoKey);\n    const algorithm = subtleAlgorithm(alg, cryptoKey.algorithm);\n    try {\n        return await crypto.subtle.verify(algorithm, cryptoKey, signature, data);\n    }\n    catch {\n        return false;\n    }\n};\nexport default verify;\n","import crypto, { isCryptoKey } from './webcrypto.js';\nimport { checkSigCryptoKey } from '../lib/crypto_key.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nimport normalize from './normalize_key.js';\nexport default async function getCryptoKey(alg, key, usage) {\n    if (usage === 'sign') {\n        key = await normalize.normalizePrivateKey(key, alg);\n    }\n    if (usage === 'verify') {\n        key = await normalize.normalizePublicKey(key, alg);\n    }\n    if (isCryptoKey(key)) {\n        checkSigCryptoKey(key, alg, usage);\n        return key;\n    }\n    if (key instanceof Uint8Array) {\n        if (!alg.startsWith('HS')) {\n            throw new TypeError(invalidKeyInput(key, ...types));\n        }\n        return crypto.subtle.importKey('raw', key, { hash: `SHA-${alg.slice(-3)}`, name: 'HMAC' }, false, [usage]);\n    }\n    throw new TypeError(invalidKeyInput(key, ...types, 'Uint8Array', 'JSON Web Key'));\n}\n","export default (alg, key) => {\n    if (alg.startsWith('RS') || alg.startsWith('PS')) {\n        const { modulusLength } = key.algorithm;\n        if (typeof modulusLength !== 'number' || modulusLength < 2048) {\n            throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);\n        }\n    }\n};\n","import { JOSENotSupported } from '../util/errors.js';\nexport default function subtleDsa(alg, algorithm) {\n    const hash = `SHA-${alg.slice(-3)}`;\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512':\n            return { hash, name: 'HMAC' };\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            return { hash, name: 'RSA-PSS', saltLength: alg.slice(-3) >> 3 };\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            return { hash, name: 'RSASSA-PKCS1-v1_5' };\n        case 'ES256':\n        case 'ES384':\n        case 'ES512':\n            return { hash, name: 'ECDSA', namedCurve: algorithm.namedCurve };\n        case 'Ed25519':\n            return { name: 'Ed25519' };\n        case 'EdDSA':\n            return { name: algorithm.name };\n        default:\n            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n}\n","import { decode as base64url } from '../../runtime/base64url.js';\nimport verify from '../../runtime/verify.js';\nimport { JOSEAlgNotAllowed, JWSInvalid, JWSSignatureVerificationFailed } from '../../util/errors.js';\nimport { concat, encoder, decoder } from '../../lib/buffer_utils.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport isObject from '../../lib/is_object.js';\nimport { checkKeyTypeWithJwk } from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nimport validateAlgorithms from '../../lib/validate_algorithms.js';\nimport { isJWK } from '../../lib/is_jwk.js';\nimport { importJWK } from '../../key/import.js';\nexport async function flattenedVerify(jws, key, options) {\n    if (!isObject(jws)) {\n        throw new JWSInvalid('Flattened JWS must be an object');\n    }\n    if (jws.protected === undefined && jws.header === undefined) {\n        throw new JWSInvalid('Flattened JWS must have either of the \"protected\" or \"header\" members');\n    }\n    if (jws.protected !== undefined && typeof jws.protected !== 'string') {\n        throw new JWSInvalid('JWS Protected Header incorrect type');\n    }\n    if (jws.payload === undefined) {\n        throw new JWSInvalid('JWS Payload missing');\n    }\n    if (typeof jws.signature !== 'string') {\n        throw new JWSInvalid('JWS Signature missing or incorrect type');\n    }\n    if (jws.header !== undefined && !isObject(jws.header)) {\n        throw new JWSInvalid('JWS Unprotected Header incorrect type');\n    }\n    let parsedProt = {};\n    if (jws.protected) {\n        try {\n            const protectedHeader = base64url(jws.protected);\n            parsedProt = JSON.parse(decoder.decode(protectedHeader));\n        }\n        catch {\n            throw new JWSInvalid('JWS Protected Header is invalid');\n        }\n    }\n    if (!isDisjoint(parsedProt, jws.header)) {\n        throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    }\n    const joseHeader = {\n        ...parsedProt,\n        ...jws.header,\n    };\n    const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options?.crit, parsedProt, joseHeader);\n    let b64 = true;\n    if (extensions.has('b64')) {\n        b64 = parsedProt.b64;\n        if (typeof b64 !== 'boolean') {\n            throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n        }\n    }\n    const { alg } = joseHeader;\n    if (typeof alg !== 'string' || !alg) {\n        throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n    }\n    const algorithms = options && validateAlgorithms('algorithms', options.algorithms);\n    if (algorithms && !algorithms.has(alg)) {\n        throw new JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter value not allowed');\n    }\n    if (b64) {\n        if (typeof jws.payload !== 'string') {\n            throw new JWSInvalid('JWS Payload must be a string');\n        }\n    }\n    else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {\n        throw new JWSInvalid('JWS Payload must be a string or an Uint8Array instance');\n    }\n    let resolvedKey = false;\n    if (typeof key === 'function') {\n        key = await key(parsedProt, jws);\n        resolvedKey = true;\n        checkKeyTypeWithJwk(alg, key, 'verify');\n        if (isJWK(key)) {\n            key = await importJWK(key, alg);\n        }\n    }\n    else {\n        checkKeyTypeWithJwk(alg, key, 'verify');\n    }\n    const data = concat(encoder.encode(jws.protected ?? ''), encoder.encode('.'), typeof jws.payload === 'string' ? encoder.encode(jws.payload) : jws.payload);\n    let signature;\n    try {\n        signature = base64url(jws.signature);\n    }\n    catch {\n        throw new JWSInvalid('Failed to base64url decode the signature');\n    }\n    const verified = await verify(alg, key, signature, data);\n    if (!verified) {\n        throw new JWSSignatureVerificationFailed();\n    }\n    let payload;\n    if (b64) {\n        try {\n            payload = base64url(jws.payload);\n        }\n        catch {\n            throw new JWSInvalid('Failed to base64url decode the payload');\n        }\n    }\n    else if (typeof jws.payload === 'string') {\n        payload = encoder.encode(jws.payload);\n    }\n    else {\n        payload = jws.payload;\n    }\n    const result = { payload };\n    if (jws.protected !== undefined) {\n        result.protectedHeader = parsedProt;\n    }\n    if (jws.header !== undefined) {\n        result.unprotectedHeader = jws.header;\n    }\n    if (resolvedKey) {\n        return { ...result, key };\n    }\n    return result;\n}\n","const isDisjoint = (...headers) => {\n    const sources = headers.filter(Boolean);\n    if (sources.length === 0 || sources.length === 1) {\n        return true;\n    }\n    let acc;\n    for (const header of sources) {\n        const parameters = Object.keys(header);\n        if (!acc || acc.size === 0) {\n            acc = new Set(parameters);\n            continue;\n        }\n        for (const parameter of parameters) {\n            if (acc.has(parameter)) {\n                return false;\n            }\n            acc.add(parameter);\n        }\n    }\n    return true;\n};\nexport default isDisjoint;\n","import { JOSENotSupported } from '../util/errors.js';\nfunction validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {\n    if (joseHeader.crit !== undefined && protectedHeader?.crit === undefined) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be integrity protected');\n    }\n    if (!protectedHeader || protectedHeader.crit === undefined) {\n        return new Set();\n    }\n    if (!Array.isArray(protectedHeader.crit) ||\n        protectedHeader.crit.length === 0 ||\n        protectedHeader.crit.some((input) => typeof input !== 'string' || input.length === 0)) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be an array of non-empty strings when present');\n    }\n    let recognized;\n    if (recognizedOption !== undefined) {\n        recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);\n    }\n    else {\n        recognized = recognizedDefault;\n    }\n    for (const parameter of protectedHeader.crit) {\n        if (!recognized.has(parameter)) {\n            throw new JOSENotSupported(`Extension Header Parameter \"${parameter}\" is not recognized`);\n        }\n        if (joseHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" is missing`);\n        }\n        if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" MUST be integrity protected`);\n        }\n    }\n    return new Set(protectedHeader.crit);\n}\nexport default validateCrit;\n","const validateAlgorithms = (option, algorithms) => {\n    if (algorithms !== undefined &&\n        (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== 'string'))) {\n        throw new TypeError(`\"${option}\" option must be an array of strings`);\n    }\n    if (!algorithms) {\n        return undefined;\n    }\n    return new Set(algorithms);\n};\nexport default validateAlgorithms;\n","const minute = 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\nconst year = day * 365.25;\nconst REGEX = /^(\\+|\\-)? ?(\\d+|\\d+\\.\\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;\nexport default (str) => {\n    const matched = REGEX.exec(str);\n    if (!matched || (matched[4] && matched[1])) {\n        throw new TypeError('Invalid time period format');\n    }\n    const value = parseFloat(matched[2]);\n    const unit = matched[3].toLowerCase();\n    let numericDate;\n    switch (unit) {\n        case 'sec':\n        case 'secs':\n        case 'second':\n        case 'seconds':\n        case 's':\n            numericDate = Math.round(value);\n            break;\n        case 'minute':\n        case 'minutes':\n        case 'min':\n        case 'mins':\n        case 'm':\n            numericDate = Math.round(value * minute);\n            break;\n        case 'hour':\n        case 'hours':\n        case 'hr':\n        case 'hrs':\n        case 'h':\n            numericDate = Math.round(value * hour);\n            break;\n        case 'day':\n        case 'days':\n        case 'd':\n            numericDate = Math.round(value * day);\n            break;\n        case 'week':\n        case 'weeks':\n        case 'w':\n            numericDate = Math.round(value * week);\n            break;\n        default:\n            numericDate = Math.round(value * year);\n            break;\n    }\n    if (matched[1] === '-' || matched[4] === 'ago') {\n        return -numericDate;\n    }\n    return numericDate;\n};\n","import { JWTClaimValidationFailed, JWTExpired, JWTInvalid } from '../util/errors.js';\nimport { decoder } from './buffer_utils.js';\nimport epoch from './epoch.js';\nimport secs from './secs.js';\nimport isObject from './is_object.js';\nconst normalizeTyp = (value) => value.toLowerCase().replace(/^application\\//, '');\nconst checkAudiencePresence = (audPayload, audOption) => {\n    if (typeof audPayload === 'string') {\n        return audOption.includes(audPayload);\n    }\n    if (Array.isArray(audPayload)) {\n        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));\n    }\n    return false;\n};\nexport default (protectedHeader, encodedPayload, options = {}) => {\n    let payload;\n    try {\n        payload = JSON.parse(decoder.decode(encodedPayload));\n    }\n    catch {\n    }\n    if (!isObject(payload)) {\n        throw new JWTInvalid('JWT Claims Set must be a top-level JSON object');\n    }\n    const { typ } = options;\n    if (typ &&\n        (typeof protectedHeader.typ !== 'string' ||\n            normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {\n        throw new JWTClaimValidationFailed('unexpected \"typ\" JWT header value', payload, 'typ', 'check_failed');\n    }\n    const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;\n    const presenceCheck = [...requiredClaims];\n    if (maxTokenAge !== undefined)\n        presenceCheck.push('iat');\n    if (audience !== undefined)\n        presenceCheck.push('aud');\n    if (subject !== undefined)\n        presenceCheck.push('sub');\n    if (issuer !== undefined)\n        presenceCheck.push('iss');\n    for (const claim of new Set(presenceCheck.reverse())) {\n        if (!(claim in payload)) {\n            throw new JWTClaimValidationFailed(`missing required \"${claim}\" claim`, payload, claim, 'missing');\n        }\n    }\n    if (issuer &&\n        !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {\n        throw new JWTClaimValidationFailed('unexpected \"iss\" claim value', payload, 'iss', 'check_failed');\n    }\n    if (subject && payload.sub !== subject) {\n        throw new JWTClaimValidationFailed('unexpected \"sub\" claim value', payload, 'sub', 'check_failed');\n    }\n    if (audience &&\n        !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [audience] : audience)) {\n        throw new JWTClaimValidationFailed('unexpected \"aud\" claim value', payload, 'aud', 'check_failed');\n    }\n    let tolerance;\n    switch (typeof options.clockTolerance) {\n        case 'string':\n            tolerance = secs(options.clockTolerance);\n            break;\n        case 'number':\n            tolerance = options.clockTolerance;\n            break;\n        case 'undefined':\n            tolerance = 0;\n            break;\n        default:\n            throw new TypeError('Invalid clockTolerance option type');\n    }\n    const { currentDate } = options;\n    const now = epoch(currentDate || new Date());\n    if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== 'number') {\n        throw new JWTClaimValidationFailed('\"iat\" claim must be a number', payload, 'iat', 'invalid');\n    }\n    if (payload.nbf !== undefined) {\n        if (typeof payload.nbf !== 'number') {\n            throw new JWTClaimValidationFailed('\"nbf\" claim must be a number', payload, 'nbf', 'invalid');\n        }\n        if (payload.nbf > now + tolerance) {\n            throw new JWTClaimValidationFailed('\"nbf\" claim timestamp check failed', payload, 'nbf', 'check_failed');\n        }\n    }\n    if (payload.exp !== undefined) {\n        if (typeof payload.exp !== 'number') {\n            throw new JWTClaimValidationFailed('\"exp\" claim must be a number', payload, 'exp', 'invalid');\n        }\n        if (payload.exp <= now - tolerance) {\n            throw new JWTExpired('\"exp\" claim timestamp check failed', payload, 'exp', 'check_failed');\n        }\n    }\n    if (maxTokenAge) {\n        const age = now - payload.iat;\n        const max = typeof maxTokenAge === 'number' ? maxTokenAge : secs(maxTokenAge);\n        if (age - tolerance > max) {\n            throw new JWTExpired('\"iat\" claim timestamp check failed (too far in the past)', payload, 'iat', 'check_failed');\n        }\n        if (age < 0 - tolerance) {\n            throw new JWTClaimValidationFailed('\"iat\" claim timestamp check failed (it should be in the past)', payload, 'iat', 'check_failed');\n        }\n    }\n    return payload;\n};\n","export default (date) => Math.floor(date.getTime() / 1000);\n","import { compactVerify } from '../jws/compact/verify.js';\nimport jwtPayload from '../lib/jwt_claims_set.js';\nimport { JWTInvalid } from '../util/errors.js';\nexport async function jwtVerify(jwt, key, options) {\n    const verified = await compactVerify(jwt, key, options);\n    if (verified.protectedHeader.crit?.includes('b64') && verified.protectedHeader.b64 === false) {\n        throw new JWTInvalid('JWTs MUST NOT use unencoded payload');\n    }\n    const payload = jwtPayload(verified.protectedHeader, verified.payload, options);\n    const result = { payload, protectedHeader: verified.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: verified.key };\n    }\n    return result;\n}\n","import { flattenedVerify } from '../flattened/verify.js';\nimport { JWSInvalid } from '../../util/errors.js';\nimport { decoder } from '../../lib/buffer_utils.js';\nexport async function compactVerify(jws, key, options) {\n    if (jws instanceof Uint8Array) {\n        jws = decoder.decode(jws);\n    }\n    if (typeof jws !== 'string') {\n        throw new JWSInvalid('Compact JWS must be a string or Uint8Array');\n    }\n    const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split('.');\n    if (length !== 3) {\n        throw new JWSInvalid('Invalid Compact JWS');\n    }\n    const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);\n    const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: verified.key };\n    }\n    return result;\n}\n","import { importJWK } from '../key/import.js';\nimport { JWKSInvalid, JOSENotSupported, JWKSNoMatchingKey, JWKSMultipleMatchingKeys, } from '../util/errors.js';\nimport isObject from '../lib/is_object.js';\nfunction getKtyFromAlg(alg) {\n    switch (typeof alg === 'string' && alg.slice(0, 2)) {\n        case 'RS':\n        case 'PS':\n            return 'RSA';\n        case 'ES':\n            return 'EC';\n        case 'Ed':\n            return 'OKP';\n        default:\n            throw new JOSENotSupported('Unsupported \"alg\" value for a JSON Web Key Set');\n    }\n}\nfunction isJWKSLike(jwks) {\n    return (jwks &&\n        typeof jwks === 'object' &&\n        Array.isArray(jwks.keys) &&\n        jwks.keys.every(isJWKLike));\n}\nfunction isJWKLike(key) {\n    return isObject(key);\n}\nfunction clone(obj) {\n    if (typeof structuredClone === 'function') {\n        return structuredClone(obj);\n    }\n    return JSON.parse(JSON.stringify(obj));\n}\nclass LocalJWKSet {\n    constructor(jwks) {\n        this._cached = new WeakMap();\n        if (!isJWKSLike(jwks)) {\n            throw new JWKSInvalid('JSON Web Key Set malformed');\n        }\n        this._jwks = clone(jwks);\n    }\n    async getKey(protectedHeader, token) {\n        const { alg, kid } = { ...protectedHeader, ...token?.header };\n        const kty = getKtyFromAlg(alg);\n        const candidates = this._jwks.keys.filter((jwk) => {\n            let candidate = kty === jwk.kty;\n            if (candidate && typeof kid === 'string') {\n                candidate = kid === jwk.kid;\n            }\n            if (candidate && typeof jwk.alg === 'string') {\n                candidate = alg === jwk.alg;\n            }\n            if (candidate && typeof jwk.use === 'string') {\n                candidate = jwk.use === 'sig';\n            }\n            if (candidate && Array.isArray(jwk.key_ops)) {\n                candidate = jwk.key_ops.includes('verify');\n            }\n            if (candidate) {\n                switch (alg) {\n                    case 'ES256':\n                        candidate = jwk.crv === 'P-256';\n                        break;\n                    case 'ES256K':\n                        candidate = jwk.crv === 'secp256k1';\n                        break;\n                    case 'ES384':\n                        candidate = jwk.crv === 'P-384';\n                        break;\n                    case 'ES512':\n                        candidate = jwk.crv === 'P-521';\n                        break;\n                    case 'Ed25519':\n                        candidate = jwk.crv === 'Ed25519';\n                        break;\n                    case 'EdDSA':\n                        candidate = jwk.crv === 'Ed25519' || jwk.crv === 'Ed448';\n                        break;\n                }\n            }\n            return candidate;\n        });\n        const { 0: jwk, length } = candidates;\n        if (length === 0) {\n            throw new JWKSNoMatchingKey();\n        }\n        if (length !== 1) {\n            const error = new JWKSMultipleMatchingKeys();\n            const { _cached } = this;\n            error[Symbol.asyncIterator] = async function* () {\n                for (const jwk of candidates) {\n                    try {\n                        yield await importWithAlgCache(_cached, jwk, alg);\n                    }\n                    catch { }\n                }\n            };\n            throw error;\n        }\n        return importWithAlgCache(this._cached, jwk, alg);\n    }\n}\nasync function importWithAlgCache(cache, jwk, alg) {\n    const cached = cache.get(jwk) || cache.set(jwk, {}).get(jwk);\n    if (cached[alg] === undefined) {\n        const key = await importJWK({ ...jwk, ext: true }, alg);\n        if (key instanceof Uint8Array || key.type !== 'public') {\n            throw new JWKSInvalid('JSON Web Key Set members must be public keys');\n        }\n        cached[alg] = key;\n    }\n    return cached[alg];\n}\nexport function createLocalJWKSet(jwks) {\n    const set = new LocalJWKSet(jwks);\n    const localJWKSet = async (protectedHeader, token) => set.getKey(protectedHeader, token);\n    Object.defineProperties(localJWKSet, {\n        jwks: {\n            value: () => clone(set._jwks),\n            enumerable: true,\n            configurable: false,\n            writable: false,\n        },\n    });\n    return localJWKSet;\n}\n","import fetchJwks from '../runtime/fetch_jwks.js';\nimport { JWKSNoMatchingKey } from '../util/errors.js';\nimport { createLocalJWKSet } from './local.js';\nimport isObject from '../lib/is_object.js';\nfunction isCloudflareWorkers() {\n    return (typeof WebSocketPair !== 'undefined' ||\n        (typeof navigator !== 'undefined' && navigator.userAgent === 'Cloudflare-Workers') ||\n        (typeof EdgeRuntime !== 'undefined' && EdgeRuntime === 'vercel'));\n}\nlet USER_AGENT;\nif (typeof navigator === 'undefined' || !navigator.userAgent?.startsWith?.('Mozilla/5.0 ')) {\n    const NAME = 'jose';\n    const VERSION = 'v5.10.0';\n    USER_AGENT = `${NAME}/${VERSION}`;\n}\nexport const jwksCache = Symbol();\nfunction isFreshJwksCache(input, cacheMaxAge) {\n    if (typeof input !== 'object' || input === null) {\n        return false;\n    }\n    if (!('uat' in input) || typeof input.uat !== 'number' || Date.now() - input.uat >= cacheMaxAge) {\n        return false;\n    }\n    if (!('jwks' in input) ||\n        !isObject(input.jwks) ||\n        !Array.isArray(input.jwks.keys) ||\n        !Array.prototype.every.call(input.jwks.keys, isObject)) {\n        return false;\n    }\n    return true;\n}\nclass RemoteJWKSet {\n    constructor(url, options) {\n        if (!(url instanceof URL)) {\n            throw new TypeError('url must be an instance of URL');\n        }\n        this._url = new URL(url.href);\n        this._options = { agent: options?.agent, headers: options?.headers };\n        this._timeoutDuration =\n            typeof options?.timeoutDuration === 'number' ? options?.timeoutDuration : 5000;\n        this._cooldownDuration =\n            typeof options?.cooldownDuration === 'number' ? options?.cooldownDuration : 30000;\n        this._cacheMaxAge = typeof options?.cacheMaxAge === 'number' ? options?.cacheMaxAge : 600000;\n        if (options?.[jwksCache] !== undefined) {\n            this._cache = options?.[jwksCache];\n            if (isFreshJwksCache(options?.[jwksCache], this._cacheMaxAge)) {\n                this._jwksTimestamp = this._cache.uat;\n                this._local = createLocalJWKSet(this._cache.jwks);\n            }\n        }\n    }\n    coolingDown() {\n        return typeof this._jwksTimestamp === 'number'\n            ? Date.now() < this._jwksTimestamp + this._cooldownDuration\n            : false;\n    }\n    fresh() {\n        return typeof this._jwksTimestamp === 'number'\n            ? Date.now() < this._jwksTimestamp + this._cacheMaxAge\n            : false;\n    }\n    async getKey(protectedHeader, token) {\n        if (!this._local || !this.fresh()) {\n            await this.reload();\n        }\n        try {\n            return await this._local(protectedHeader, token);\n        }\n        catch (err) {\n            if (err instanceof JWKSNoMatchingKey) {\n                if (this.coolingDown() === false) {\n                    await this.reload();\n                    return this._local(protectedHeader, token);\n                }\n            }\n            throw err;\n        }\n    }\n    async reload() {\n        if (this._pendingFetch && isCloudflareWorkers()) {\n            this._pendingFetch = undefined;\n        }\n        const headers = new Headers(this._options.headers);\n        if (USER_AGENT && !headers.has('User-Agent')) {\n            headers.set('User-Agent', USER_AGENT);\n            this._options.headers = Object.fromEntries(headers.entries());\n        }\n        this._pendingFetch || (this._pendingFetch = fetchJwks(this._url, this._timeoutDuration, this._options)\n            .then((json) => {\n            this._local = createLocalJWKSet(json);\n            if (this._cache) {\n                this._cache.uat = Date.now();\n                this._cache.jwks = json;\n            }\n            this._jwksTimestamp = Date.now();\n            this._pendingFetch = undefined;\n        })\n            .catch((err) => {\n            this._pendingFetch = undefined;\n            throw err;\n        }));\n        await this._pendingFetch;\n    }\n}\nexport function createRemoteJWKSet(url, options) {\n    const set = new RemoteJWKSet(url, options);\n    const remoteJWKSet = async (protectedHeader, token) => set.getKey(protectedHeader, token);\n    Object.defineProperties(remoteJWKSet, {\n        coolingDown: {\n            get: () => set.coolingDown(),\n            enumerable: true,\n            configurable: false,\n        },\n        fresh: {\n            get: () => set.fresh(),\n            enumerable: true,\n            configurable: false,\n        },\n        reload: {\n            value: () => set.reload(),\n            enumerable: true,\n            configurable: false,\n            writable: false,\n        },\n        reloading: {\n            get: () => !!set._pendingFetch,\n            enumerable: true,\n            configurable: false,\n        },\n        jwks: {\n            value: () => set._local?.jwks(),\n            enumerable: true,\n            configurable: false,\n            writable: false,\n        },\n    });\n    return remoteJWKSet;\n}\nexport const experimental_jwksCache = jwksCache;\n","import { JOSEError, JWKSTimeout } from '../util/errors.js';\nconst fetchJwks = async (url, timeout, options) => {\n    let controller;\n    let id;\n    let timedOut = false;\n    if (typeof AbortController === 'function') {\n        controller = new AbortController();\n        id = setTimeout(() => {\n            timedOut = true;\n            controller.abort();\n        }, timeout);\n    }\n    const response = await fetch(url.href, {\n        signal: controller ? controller.signal : undefined,\n        redirect: 'manual',\n        headers: options.headers,\n    }).catch((err) => {\n        if (timedOut)\n            throw new JWKSTimeout();\n        throw err;\n    });\n    if (id !== undefined)\n        clearTimeout(id);\n    if (response.status !== 200) {\n        throw new JOSEError('Expected 200 OK from the JSON Web Key Set HTTP response');\n    }\n    try {\n        return await response.json();\n    }\n    catch {\n        throw new JOSEError('Failed to parse the JSON Web Key Set HTTP response as JSON');\n    }\n};\nexport default fetchJwks;\n","import * as base64url from '../runtime/base64url.js';\nexport const encode = base64url.encode;\nexport const decode = base64url.decode;\n","/**\n * Sign in with QuID Button\n * Vanilla JavaScript component for QuID authentication\n */\n\nimport { QuIDClient } from '../core/quid-client';\nimport { SigninOptions, ComponentStyle, AuthenticationResponse } from '../types';\n\nexport class QuIDSigninButton {\n  private client: QuIDClient;\n  private container: HTMLElement;\n  private button: HTMLButtonElement;\n  private options: Required<SigninOptions>;\n  private isLoading = false;\n\n  constructor(container: HTMLElement | string, options: SigninOptions = {}) {\n    // Get container element\n    if (typeof container === 'string') {\n      const element = document.querySelector(container) as HTMLElement;\n      if (!element) {\n        throw new Error(`Container element not found: ${container}`);\n      }\n      this.container = element;\n    } else {\n      this.container = container;\n    }\n\n    // Set default options\n    this.options = {\n      challenge: options.challenge || '',\n      userVerification: options.userVerification || 'preferred',\n      timeout: options.timeout || 60000,\n      onSuccess: options.onSuccess || (() => {}),\n      onError: options.onError || (() => {}),\n      style: options.style || {},\n      buttonText: options.buttonText || 'Sign in with QuID',\n      showBranding: options.showBranding !== false\n    };\n\n    // Initialize QuID client\n    this.client = new QuIDClient();\n\n    // Create the button\n    this.createButton();\n    this.setupEventListeners();\n  }\n\n  /**\n   * Create the signin button element\n   */\n  private createButton(): void {\n    this.button = document.createElement('button');\n    this.button.type = 'button';\n    this.button.className = 'quid-signin-button';\n    \n    // Apply styles\n    this.applyStyles();\n    \n    // Set content\n    this.updateButtonContent();\n    \n    // Add to container\n    this.container.appendChild(this.button);\n  }\n\n  /**\n   * Apply styles to the button\n   */\n  private applyStyles(): void {\n    const defaultStyle: ComponentStyle = {\n      width: '100%',\n      height: '44px',\n      backgroundColor: '#667eea',\n      color: '#ffffff',\n      borderRadius: '6px',\n      fontFamily: '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif',\n      fontSize: '16px',\n      padding: '0 16px',\n      margin: '8px 0'\n    };\n\n    const style = { ...defaultStyle, ...this.options.style };\n\n    // Apply styles\n    Object.assign(this.button.style, {\n      width: style.width,\n      height: style.height,\n      backgroundColor: style.backgroundColor,\n      color: style.color,\n      borderRadius: style.borderRadius,\n      fontFamily: style.fontFamily,\n      fontSize: style.fontSize,\n      padding: style.padding,\n      margin: style.margin,\n      border: 'none',\n      cursor: 'pointer',\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'center',\n      gap: '8px',\n      transition: 'all 0.2s ease',\n      textDecoration: 'none',\n      fontWeight: '500',\n      lineHeight: '1',\n      outline: 'none',\n      position: 'relative',\n      overflow: 'hidden'\n    });\n\n    // Add custom class if provided\n    if (style.className) {\n      this.button.className += ` ${style.className}`;\n    }\n\n    // Add hover effects\n    this.button.addEventListener('mouseenter', () => {\n      if (!this.isLoading) {\n        this.button.style.transform = 'translateY(-1px)';\n        this.button.style.boxShadow = '0 4px 12px rgba(102, 126, 234, 0.3)';\n      }\n    });\n\n    this.button.addEventListener('mouseleave', () => {\n      if (!this.isLoading) {\n        this.button.style.transform = 'translateY(0)';\n        this.button.style.boxShadow = 'none';\n      }\n    });\n  }\n\n  /**\n   * Update button content\n   */\n  private updateButtonContent(): void {\n    if (this.isLoading) {\n      this.button.innerHTML = `\n        <div class=\"quid-spinner\" style=\"\n          width: 16px;\n          height: 16px;\n          border: 2px solid transparent;\n          border-top: 2px solid currentColor;\n          border-radius: 50%;\n          animation: quid-spin 1s linear infinite;\n        \"></div>\n        <span>Authenticating...</span>\n      `;\n    } else {\n      const icon = this.options.showBranding ? \n        '<span style=\"font-size: 18px;\"></span>' : '';\n      \n      this.button.innerHTML = `\n        ${icon}\n        <span>${this.options.buttonText}</span>\n      `;\n    }\n\n    // Add spinner animation CSS if not already added\n    if (!document.querySelector('#quid-spinner-styles')) {\n      const style = document.createElement('style');\n      style.id = 'quid-spinner-styles';\n      style.textContent = `\n        @keyframes quid-spin {\n          0% { transform: rotate(0deg); }\n          100% { transform: rotate(360deg); }\n        }\n      `;\n      document.head.appendChild(style);\n    }\n  }\n\n  /**\n   * Set up event listeners\n   */\n  private setupEventListeners(): void {\n    this.button.addEventListener('click', this.handleClick.bind(this));\n    \n    // Listen for QuID client events\n    this.client.on((event) => {\n      if (event.type === 'ready' && !this.client.extensionAvailable) {\n        this.showWarning();\n      }\n    });\n  }\n\n  /**\n   * Handle button click\n   */\n  private async handleClick(): Promise<void> {\n    if (this.isLoading) {\n      return;\n    }\n\n    try {\n      this.setLoading(true);\n\n      // Generate challenge if not provided\n      const challenge = this.options.challenge || this.generateChallenge();\n\n      // Authenticate\n      const response = await this.client.authenticate({\n        challenge,\n        userVerification: this.options.userVerification,\n        timeout: this.options.timeout,\n        origin: window.location.origin\n      });\n\n      if (response.success) {\n        this.options.onSuccess(response);\n      } else {\n        this.options.onError(new Error(response.error || 'Authentication failed'));\n      }\n\n    } catch (error) {\n      this.options.onError(error instanceof Error ? error : new Error('Authentication failed'));\n    } finally {\n      this.setLoading(false);\n    }\n  }\n\n  /**\n   * Set loading state\n   */\n  private setLoading(loading: boolean): void {\n    this.isLoading = loading;\n    this.button.disabled = loading;\n    this.updateButtonContent();\n    \n    if (loading) {\n      this.button.style.transform = 'translateY(0)';\n      this.button.style.boxShadow = 'none';\n      this.button.style.cursor = 'wait';\n    } else {\n      this.button.style.cursor = 'pointer';\n    }\n  }\n\n  /**\n   * Show warning when extension is not available\n   */\n  private showWarning(): void {\n    const warningElement = document.createElement('div');\n    warningElement.className = 'quid-warning';\n    warningElement.style.cssText = `\n      background: #fff3cd;\n      border: 1px solid #ffeaa7;\n      color: #856404;\n      padding: 8px 12px;\n      border-radius: 4px;\n      font-size: 12px;\n      margin-top: 4px;\n      font-family: ${this.options.style?.fontFamily || 'inherit'};\n    `;\n    warningElement.innerHTML = `\n       QuID browser extension not detected. \n      <a href=\"https://quid.dev/download\" target=\"_blank\" style=\"color: inherit; text-decoration: underline;\">\n        Install extension\n      </a> for full functionality.\n    `;\n\n    this.container.appendChild(warningElement);\n\n    // Auto-hide after 10 seconds\n    setTimeout(() => {\n      if (warningElement.parentElement) {\n        warningElement.parentElement.removeChild(warningElement);\n      }\n    }, 10000);\n  }\n\n  /**\n   * Generate random challenge\n   */\n  private generateChallenge(): string {\n    const array = new Uint8Array(32);\n    crypto.getRandomValues(array);\n    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');\n  }\n\n  /**\n   * Update options\n   */\n  public updateOptions(newOptions: Partial<SigninOptions>): void {\n    Object.assign(this.options, newOptions);\n    this.applyStyles();\n    this.updateButtonContent();\n  }\n\n  /**\n   * Destroy the component\n   */\n  public destroy(): void {\n    if (this.button && this.button.parentElement) {\n      this.button.parentElement.removeChild(this.button);\n    }\n    this.client.disconnect();\n  }\n\n  /**\n   * Get the underlying QuID client\n   */\n  public getClient(): QuIDClient {\n    return this.client;\n  }\n}\n\n/**\n * Factory function to create signin button\n */\nexport function createSigninButton(container: HTMLElement | string, options?: SigninOptions): QuIDSigninButton {\n  return new QuIDSigninButton(container, options);\n}","/**\n * QuID React Signin Button Component\n * React wrapper for QuID authentication\n */\n\nimport React, { useEffect, useRef, useState, useCallback } from 'react';\nimport { QuIDClient } from '../../core/quid-client';\nimport { SigninOptions, AuthenticationResponse, QuIDEvent } from '../../types';\n\nexport interface QuIDSigninButtonProps extends Omit<SigninOptions, 'onSuccess' | 'onError'> {\n  /** Callback when authentication succeeds */\n  onSuccess?: (response: AuthenticationResponse) => void;\n  /** Callback when authentication fails */\n  onError?: (error: Error) => void;\n  /** Additional CSS class names */\n  className?: string;\n  /** Whether the button is disabled */\n  disabled?: boolean;\n  /** Children to render instead of default button text */\n  children?: React.ReactNode;\n}\n\n/**\n * QuID Signin Button React Component\n */\nexport const QuIDSigninButton: React.FC<QuIDSigninButtonProps> = ({\n  challenge,\n  userVerification = 'preferred',\n  timeout = 60000,\n  onSuccess,\n  onError,\n  style = {},\n  buttonText = 'Sign in with QuID',\n  showBranding = true,\n  className = '',\n  disabled = false,\n  children,\n  ...props\n}) => {\n  const clientRef = useRef<QuIDClient | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [isReady, setIsReady] = useState(false);\n  const [extensionAvailable, setExtensionAvailable] = useState(false);\n  const [showWarning, setShowWarning] = useState(false);\n\n  // Initialize QuID client\n  useEffect(() => {\n    clientRef.current = new QuIDClient();\n    \n    const unsubscribe = clientRef.current.on((event: QuIDEvent) => {\n      switch (event.type) {\n        case 'ready':\n          setIsReady(true);\n          break;\n        case 'extension-connected':\n          setExtensionAvailable(true);\n          break;\n        case 'extension-disconnected':\n          setExtensionAvailable(false);\n          setShowWarning(true);\n          break;\n      }\n    });\n\n    return () => {\n      unsubscribe();\n      if (clientRef.current) {\n        clientRef.current.disconnect();\n      }\n    };\n  }, []);\n\n  // Check extension availability after ready\n  useEffect(() => {\n    if (isReady && clientRef.current) {\n      const available = clientRef.current.extensionAvailable;\n      setExtensionAvailable(available);\n      if (!available) {\n        setShowWarning(true);\n        // Auto-hide warning after 10 seconds\n        setTimeout(() => setShowWarning(false), 10000);\n      }\n    }\n  }, [isReady]);\n\n  const handleClick = useCallback(async () => {\n    if (!clientRef.current || isLoading || disabled) {\n      return;\n    }\n\n    try {\n      setIsLoading(true);\n\n      // Generate challenge if not provided\n      const authChallenge = challenge || generateChallenge();\n\n      // Authenticate\n      const response = await clientRef.current.authenticate({\n        challenge: authChallenge,\n        userVerification,\n        timeout,\n        origin: window.location.origin\n      });\n\n      if (response.success) {\n        onSuccess?.(response);\n      } else {\n        onError?.(new Error(response.error || 'Authentication failed'));\n      }\n\n    } catch (error) {\n      onError?.(error instanceof Error ? error : new Error('Authentication failed'));\n    } finally {\n      setIsLoading(false);\n    }\n  }, [challenge, userVerification, timeout, onSuccess, onError, isLoading, disabled]);\n\n  const generateChallenge = (): string => {\n    const array = new Uint8Array(32);\n    crypto.getRandomValues(array);\n    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');\n  };\n\n  const defaultStyle: React.CSSProperties = {\n    width: '100%',\n    height: '44px',\n    backgroundColor: '#667eea',\n    color: '#ffffff',\n    borderRadius: '6px',\n    fontFamily: '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif',\n    fontSize: '16px',\n    padding: '0 16px',\n    margin: '8px 0',\n    border: 'none',\n    cursor: isLoading || disabled ? 'not-allowed' : 'pointer',\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n    gap: '8px',\n    transition: 'all 0.2s ease',\n    textDecoration: 'none',\n    fontWeight: '500',\n    lineHeight: '1',\n    outline: 'none',\n    position: 'relative',\n    overflow: 'hidden',\n    opacity: disabled ? 0.6 : 1,\n    ...style\n  };\n\n  const buttonContent = children || (\n    <>\n      {showBranding && <span style={{ fontSize: '18px' }}></span>}\n      <span>{isLoading ? 'Authenticating...' : buttonText}</span>\n      {isLoading && (\n        <div\n          style={{\n            width: '16px',\n            height: '16px',\n            border: '2px solid transparent',\n            borderTop: '2px solid currentColor',\n            borderRadius: '50%',\n            animation: 'spin 1s linear infinite'\n          }}\n        />\n      )}\n    </>\n  );\n\n  return (\n    <div>\n      <button\n        type=\"button\"\n        onClick={handleClick}\n        disabled={disabled || isLoading || !isReady}\n        className={`quid-signin-button ${className}`}\n        style={defaultStyle}\n        {...props}\n      >\n        {buttonContent}\n      </button>\n      \n      {showWarning && (\n        <div\n          style={{\n            background: '#fff3cd',\n            border: '1px solid #ffeaa7',\n            color: '#856404',\n            padding: '8px 12px',\n            borderRadius: '4px',\n            fontSize: '12px',\n            marginTop: '4px',\n            fontFamily: defaultStyle.fontFamily\n          }}\n        >\n           QuID browser extension not detected.{' '}\n          <a\n            href=\"https://quid.dev/download\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            style={{ color: 'inherit', textDecoration: 'underline' }}\n          >\n            Install extension\n          </a>{' '}\n          for full functionality.\n        </div>\n      )}\n      \n      <style jsx>{`\n        @keyframes spin {\n          0% { transform: rotate(0deg); }\n          100% { transform: rotate(360deg); }\n        }\n      `}</style>\n    </div>\n  );\n};\n\nexport default QuIDSigninButton;","/**\n * useQuID React Hook\n * React hook for QuID authentication\n */\n\nimport { useEffect, useState, useCallback, useRef } from 'react';\nimport { QuIDClient } from '../../core/quid-client';\nimport {\n  QuIDConfig,\n  QuIDIdentity,\n  AuthenticationRequest,\n  AuthenticationResponse,\n  CreateIdentityRequest,\n  QuIDEvent\n} from '../../types';\n\nexport interface UseQuIDOptions extends QuIDConfig {\n  /** Auto-initialize the client */\n  autoInit?: boolean;\n}\n\nexport interface UseQuIDReturn {\n  /** QuID client instance */\n  client: QuIDClient | null;\n  /** Whether QuID is ready */\n  isReady: boolean;\n  /** Whether QuID extension is available */\n  extensionAvailable: boolean;\n  /** Loading state */\n  isLoading: boolean;\n  /** Error state */\n  error: Error | null;\n  /** Available identities */\n  identities: QuIDIdentity[];\n  /** Authenticate with QuID */\n  authenticate: (request?: Partial<AuthenticationRequest>) => Promise<AuthenticationResponse>;\n  /** Create a new identity */\n  createIdentity: (request: CreateIdentityRequest) => Promise<QuIDIdentity>;\n  /** Refresh identities */\n  refreshIdentities: () => Promise<void>;\n  /** Get status */\n  getStatus: () => Promise<{\n    ready: boolean;\n    extensionAvailable: boolean;\n    identityCount: number;\n    version: string;\n  }>;\n  /** Clear error */\n  clearError: () => void;\n}\n\n/**\n * useQuID Hook\n */\nexport function useQuID(options: UseQuIDOptions = {}): UseQuIDReturn {\n  const { autoInit = true, ...config } = options;\n  \n  const clientRef = useRef<QuIDClient | null>(null);\n  const [isReady, setIsReady] = useState(false);\n  const [extensionAvailable, setExtensionAvailable] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [identities, setIdentities] = useState<QuIDIdentity[]>([]);\n\n  // Initialize client\n  useEffect(() => {\n    if (!autoInit) return;\n\n    const initClient = async () => {\n      try {\n        setIsLoading(true);\n        setError(null);\n\n        clientRef.current = new QuIDClient(config);\n\n        // Set up event listeners\n        const unsubscribe = clientRef.current.on((event: QuIDEvent) => {\n          switch (event.type) {\n            case 'ready':\n              setIsReady(true);\n              setExtensionAvailable(clientRef.current?.extensionAvailable || false);\n              break;\n            case 'extension-connected':\n              setExtensionAvailable(true);\n              break;\n            case 'extension-disconnected':\n              setExtensionAvailable(false);\n              break;\n            case 'error':\n              setError(event.data);\n              break;\n          }\n        });\n\n        // Cleanup function\n        return unsubscribe;\n\n      } catch (err) {\n        setError(err instanceof Error ? err : new Error('Failed to initialize QuID'));\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    const cleanup = initClient();\n\n    return () => {\n      cleanup.then(unsubscribe => unsubscribe?.());\n      if (clientRef.current) {\n        clientRef.current.disconnect();\n        clientRef.current = null;\n      }\n    };\n  }, [autoInit, config]);\n\n  // Load identities when ready\n  useEffect(() => {\n    if (isReady && extensionAvailable) {\n      refreshIdentities();\n    }\n  }, [isReady, extensionAvailable]);\n\n  const authenticate = useCallback(async (request: Partial<AuthenticationRequest> = {}): Promise<AuthenticationResponse> => {\n    if (!clientRef.current) {\n      throw new Error('QuID client not initialized');\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const response = await clientRef.current.authenticate(request);\n      return response;\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Authentication failed');\n      setError(error);\n      return {\n        success: false,\n        error: error.message\n      };\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);\n\n  const createIdentity = useCallback(async (request: CreateIdentityRequest): Promise<QuIDIdentity> => {\n    if (!clientRef.current) {\n      throw new Error('QuID client not initialized');\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const identity = await clientRef.current.createIdentity(request);\n      \n      // Refresh identities list\n      await refreshIdentities();\n      \n      return identity;\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Failed to create identity');\n      setError(error);\n      throw error;\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);\n\n  const refreshIdentities = useCallback(async (): Promise<void> => {\n    if (!clientRef.current || !extensionAvailable) {\n      setIdentities([]);\n      return;\n    }\n\n    try {\n      const identityList = await clientRef.current.getIdentities();\n      setIdentities(identityList);\n    } catch (err) {\n      console.warn('Failed to refresh identities:', err);\n      setIdentities([]);\n    }\n  }, [extensionAvailable]);\n\n  const getStatus = useCallback(async () => {\n    if (!clientRef.current) {\n      return {\n        ready: false,\n        extensionAvailable: false,\n        identityCount: 0,\n        version: '1.0.0'\n      };\n    }\n\n    return await clientRef.current.getStatus();\n  }, []);\n\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  return {\n    client: clientRef.current,\n    isReady,\n    extensionAvailable,\n    isLoading,\n    error,\n    identities,\n    authenticate,\n    createIdentity,\n    refreshIdentities,\n    getStatus,\n    clearError\n  };\n}\n\nexport default useQuID;","/**\n * QuID JavaScript SDK\n * Universal quantum-resistant authentication for web applications\n */\n\n// Core exports\nexport { QuIDClient } from './core/quid-client';\nexport { ExtensionConnector } from './core/extension-connector';\nexport { WebAuthnBridge } from './core/webauthn-bridge';\n\n// OAuth exports\nexport { QuIDOAuthClient } from './oauth/oauth-client';\n\n// Component exports\nexport { QuIDSigninButton, createSigninButton } from './components/signin-button';\n\n// React exports\nexport { \n  QuIDSigninButton as QuIDSigninButtonReact,\n  default as QuIDSigninButtonReactDefault \n} from './components/react/signin-button';\nexport { useQuID, default as useQuIDDefault } from './components/react/use-quid';\n\n// Utility exports\nexport { EventEmitter } from './utils/event-emitter';\nexport { Logger } from './utils/logger';\n\n// Type exports\nexport type {\n  QuIDConfig,\n  QuIDIdentity,\n  PublicKeyInfo,\n  SecurityLevel,\n  UserVerificationRequirement,\n  AuthenticationRequest,\n  AuthenticationResponse,\n  QuIDCredential,\n  SigninOptions,\n  ComponentStyle,\n  OAuthConfig,\n  OAuthProvider,\n  OAuthTokenResponse,\n  QuIDEvent,\n  QuIDEventType,\n  QuIDSDKError,\n  CreateIdentityRequest,\n  WebAuthnCredentialCreationOptions,\n  WebAuthnCredentialRequestOptions\n} from './types';\n\nexport type {\n  PublicKeyCredentialDescriptor,\n  PublicKeyCredentialParameters,\n  AuthenticatorSelectionCriteria,\n  AttestationConveyancePreference,\n  AuthenticatorTransport\n} from './browser-types';\n\n// Default export\nexport default QuIDClient;","/**\n * OAuth/OIDC Client\n * Provides OAuth and OpenID Connect integration for QuID\n */\n\nimport { QuIDClient } from '../core/quid-client';\nimport { \n  OAuthConfig, \n  OAuthProvider, \n  OAuthTokenResponse,\n  AuthenticationResponse \n} from '../types';\nimport { Logger } from '../utils/logger';\nimport * as jose from 'jose';\n\nexport class QuIDOAuthClient {\n  private quidClient: QuIDClient;\n  private config: Required<OAuthConfig>;\n  private logger: Logger;\n\n  constructor(config: OAuthConfig, quidClient?: QuIDClient) {\n    this.quidClient = quidClient || new QuIDClient();\n    this.logger = new Logger(false);\n    \n    // Set default provider configuration\n    const defaultProvider: OAuthProvider = {\n      authorizationEndpoint: '/oauth/authorize',\n      tokenEndpoint: '/oauth/token',\n      userInfoEndpoint: '/oauth/userinfo',\n      jwksEndpoint: '/oauth/jwks'\n    };\n\n    this.config = {\n      clientId: config.clientId,\n      clientSecret: config.clientSecret || '',\n      redirectUri: config.redirectUri,\n      scopes: config.scopes || ['openid', 'profile'],\n      provider: { ...defaultProvider, ...config.provider }\n    };\n  }\n\n  /**\n   * Generate OAuth authorization URL with QuID authentication\n   */\n  public generateAuthUrl(options: {\n    state?: string;\n    nonce?: string;\n    additionalParams?: Record<string, string>;\n  } = {}): string {\n    const { state, nonce, additionalParams = {} } = options;\n    \n    const params = new URLSearchParams({\n      response_type: 'code',\n      client_id: this.config.clientId,\n      redirect_uri: this.config.redirectUri,\n      scope: this.config.scopes.join(' '),\n      ...additionalParams\n    });\n\n    if (state) {\n      params.set('state', state);\n    }\n\n    if (nonce) {\n      params.set('nonce', nonce);\n    }\n\n    // Add QuID-specific parameters\n    params.set('quid_enabled', 'true');\n    params.set('response_mode', 'query');\n\n    const baseUrl = this.config.provider.authorizationEndpoint;\n    return `${baseUrl}?${params.toString()}`;\n  }\n\n  /**\n   * Handle OAuth callback with QuID authentication\n   */\n  public async handleCallback(callbackUrl: string): Promise<{\n    tokens: OAuthTokenResponse;\n    userInfo?: any;\n  }> {\n    const url = new URL(callbackUrl);\n    const code = url.searchParams.get('code');\n    const state = url.searchParams.get('state');\n    const error = url.searchParams.get('error');\n\n    if (error) {\n      throw new Error(`OAuth error: ${error} - ${url.searchParams.get('error_description')}`);\n    }\n\n    if (!code) {\n      throw new Error('No authorization code received');\n    }\n\n    this.logger.debug('Processing OAuth callback with code:', code);\n\n    // Exchange code for tokens using QuID authentication\n    const tokens = await this.exchangeCodeForTokens(code, state);\n    \n    // Get user info if scope includes profile\n    let userInfo;\n    if (this.config.scopes.includes('profile') && this.config.provider.userInfoEndpoint) {\n      userInfo = await this.getUserInfo(tokens.accessToken);\n    }\n\n    return { tokens, userInfo };\n  }\n\n  /**\n   * Exchange authorization code for tokens using QuID authentication\n   */\n  private async exchangeCodeForTokens(code: string, state?: string): Promise<OAuthTokenResponse> {\n    try {\n      // Use QuID to authenticate the token request\n      const authResponse = await this.quidClient.authenticate({\n        challenge: this.generateChallenge(),\n        origin: window.location.origin\n      });\n\n      if (!authResponse.success) {\n        throw new Error('QuID authentication failed for token exchange');\n      }\n\n      // Prepare token request\n      const tokenRequest = {\n        grant_type: 'authorization_code',\n        client_id: this.config.clientId,\n        client_secret: this.config.clientSecret,\n        code,\n        redirect_uri: this.config.redirectUri,\n        quid_credential: JSON.stringify(authResponse.credential)\n      };\n\n      const response = await fetch(this.config.provider.tokenEndpoint, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          'Accept': 'application/json'\n        },\n        body: new URLSearchParams(tokenRequest).toString()\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(`Token exchange failed: ${errorData.error || response.statusText}`);\n      }\n\n      const tokenData = await response.json();\n      \n      this.logger.debug('Token exchange successful');\n\n      return {\n        accessToken: tokenData.access_token,\n        tokenType: tokenData.token_type || 'Bearer',\n        expiresIn: tokenData.expires_in,\n        refreshToken: tokenData.refresh_token,\n        scope: tokenData.scope,\n        idToken: tokenData.id_token\n      };\n\n    } catch (error) {\n      this.logger.error('Token exchange failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Refresh access token using QuID authentication\n   */\n  public async refreshToken(refreshToken: string): Promise<OAuthTokenResponse> {\n    if (!refreshToken) {\n      throw new Error('Refresh token is required');\n    }\n\n    try {\n      // Use QuID to authenticate the refresh request\n      const authResponse = await this.quidClient.authenticate({\n        challenge: this.generateChallenge(),\n        origin: window.location.origin\n      });\n\n      if (!authResponse.success) {\n        throw new Error('QuID authentication failed for token refresh');\n      }\n\n      const refreshRequest = {\n        grant_type: 'refresh_token',\n        client_id: this.config.clientId,\n        client_secret: this.config.clientSecret,\n        refresh_token: refreshToken,\n        quid_credential: JSON.stringify(authResponse.credential)\n      };\n\n      const response = await fetch(this.config.provider.tokenEndpoint, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          'Accept': 'application/json'\n        },\n        body: new URLSearchParams(refreshRequest).toString()\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(`Token refresh failed: ${errorData.error || response.statusText}`);\n      }\n\n      const tokenData = await response.json();\n      \n      return {\n        accessToken: tokenData.access_token,\n        tokenType: tokenData.token_type || 'Bearer',\n        expiresIn: tokenData.expires_in,\n        refreshToken: tokenData.refresh_token || refreshToken, // Use new refresh token if provided\n        scope: tokenData.scope,\n        idToken: tokenData.id_token\n      };\n\n    } catch (error) {\n      this.logger.error('Token refresh failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get user information using access token\n   */\n  public async getUserInfo(accessToken: string): Promise<any> {\n    if (!this.config.provider.userInfoEndpoint) {\n      throw new Error('User info endpoint not configured');\n    }\n\n    try {\n      const response = await fetch(this.config.provider.userInfoEndpoint, {\n        headers: {\n          'Authorization': `Bearer ${accessToken}`,\n          'Accept': 'application/json'\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to fetch user info: ${response.statusText}`);\n      }\n\n      return await response.json();\n\n    } catch (error) {\n      this.logger.error('Failed to get user info:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Verify and decode ID token\n   */\n  public async verifyIdToken(idToken: string): Promise<any> {\n    if (!this.config.provider.jwksEndpoint) {\n      this.logger.warn('JWKS endpoint not configured, skipping token verification');\n      return jose.decodeJwt(idToken);\n    }\n\n    try {\n      // Fetch JWKS\n      const jwks = await jose.createRemoteJWKSet(new URL(this.config.provider.jwksEndpoint));\n      \n      // Verify and decode the token\n      const { payload } = await jose.jwtVerify(idToken, jwks, {\n        issuer: this.extractIssuerFromEndpoint(),\n        audience: this.config.clientId\n      });\n\n      return payload;\n\n    } catch (error) {\n      this.logger.error('ID token verification failed:', error);\n      throw new Error('Invalid ID token');\n    }\n  }\n\n  /**\n   * Logout from OAuth provider\n   */\n  public generateLogoutUrl(options: {\n    postLogoutRedirectUri?: string;\n    state?: string;\n  } = {}): string {\n    const { postLogoutRedirectUri, state } = options;\n    \n    // Standard logout endpoint (RFC 7636)\n    const logoutEndpoint = this.config.provider.authorizationEndpoint.replace('/authorize', '/logout');\n    \n    const params = new URLSearchParams({\n      client_id: this.config.clientId\n    });\n\n    if (postLogoutRedirectUri) {\n      params.set('post_logout_redirect_uri', postLogoutRedirectUri);\n    }\n\n    if (state) {\n      params.set('state', state);\n    }\n\n    return `${logoutEndpoint}?${params.toString()}`;\n  }\n\n  /**\n   * Create PKCE challenge for secure OAuth flow\n   */\n  public generatePKCEChallenge(): { codeVerifier: string; codeChallenge: string } {\n    // Generate code verifier\n    const array = new Uint8Array(32);\n    crypto.getRandomValues(array);\n    const codeVerifier = this.base64URLEncode(array);\n    \n    // Generate code challenge\n    const encoder = new TextEncoder();\n    const data = encoder.encode(codeVerifier);\n    return crypto.subtle.digest('SHA-256', data).then(hash => {\n      const codeChallenge = this.base64URLEncode(new Uint8Array(hash));\n      return { codeVerifier, codeChallenge };\n    }) as any; // Simplified for demo\n  }\n\n  /**\n   * Start OAuth flow with PKCE and QuID integration\n   */\n  public async startSecureFlow(options: {\n    state?: string;\n    nonce?: string;\n  } = {}): Promise<{ authUrl: string; codeVerifier: string }> {\n    const { state, nonce } = options;\n    \n    // Generate PKCE challenge\n    const { codeVerifier, codeChallenge } = this.generatePKCEChallenge();\n    \n    // Generate auth URL with PKCE\n    const authUrl = this.generateAuthUrl({\n      state,\n      nonce,\n      additionalParams: {\n        code_challenge: codeChallenge,\n        code_challenge_method: 'S256'\n      }\n    });\n\n    return { authUrl, codeVerifier };\n  }\n\n  private generateChallenge(): string {\n    const array = new Uint8Array(32);\n    crypto.getRandomValues(array);\n    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');\n  }\n\n  private base64URLEncode(buffer: Uint8Array): string {\n    const base64 = btoa(String.fromCharCode(...buffer));\n    return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n  }\n\n  private extractIssuerFromEndpoint(): string {\n    try {\n      const url = new URL(this.config.provider.authorizationEndpoint);\n      return `${url.protocol}//${url.host}`;\n    } catch {\n      return 'unknown';\n    }\n  }\n\n  /**\n   * Update configuration\n   */\n  public updateConfig(newConfig: Partial<OAuthConfig>): void {\n    Object.assign(this.config, newConfig);\n  }\n\n  /**\n   * Get current configuration\n   */\n  public getConfig(): OAuthConfig {\n    return { ...this.config };\n  }\n}","import { decode as base64url } from './base64url.js';\nimport { decoder } from '../lib/buffer_utils.js';\nimport isObject from '../lib/is_object.js';\nimport { JWTInvalid } from './errors.js';\nexport function decodeJwt(jwt) {\n    if (typeof jwt !== 'string')\n        throw new JWTInvalid('JWTs must use Compact JWS serialization, JWT must be a string');\n    const { 1: payload, length } = jwt.split('.');\n    if (length === 5)\n        throw new JWTInvalid('Only JWTs using Compact JWS serialization can be decoded');\n    if (length !== 3)\n        throw new JWTInvalid('Invalid JWT');\n    if (!payload)\n        throw new JWTInvalid('JWTs must contain a payload');\n    let decoded;\n    try {\n        decoded = base64url(payload);\n    }\n    catch {\n        throw new JWTInvalid('Failed to base64url decode the payload');\n    }\n    let result;\n    try {\n        result = JSON.parse(decoder.decode(decoded));\n    }\n    catch {\n        throw new JWTInvalid('Failed to parse the decoded payload as JSON');\n    }\n    if (!isObject(result))\n        throw new JWTInvalid('Invalid JWT Claims Set');\n    return result;\n}\n"],"names":["ExtensionConnector","constructor","config","logger","this","isConnected","connect","window","_a","chrome","runtime","debug","detectExtension","status","sendMessage","type","undefined","info","error","disconnect","extensionId","getIdentities","Error","response","success","identities","map","mapIdentity","createIdentity","request","name","securityLevel","networks","identity","authenticate","challenge","allowCredentials","userVerification","timeout","credential","message","signChallenge","identityId","origin","location","signature","QuID","isAvailable","Promise","resolve","setTimeout","handler","event","detail","available","clearTimeout","removeEventListener","addEventListener","dispatchEvent","CustomEvent","reject","lastError","handleQuIDAPIMessage","handleCustomEventMessage","isReady","then","catch","requestId","Date","now","Math","random","toString","substr","extIdentity","id","security_level","isActive","is_active","createdAt","created_at","lastUsedAt","last_used_at","publicKey","public_key","WebAuthnBridge","client","init","isWebAuthnSupported","warn","navigator","credentials","create","get","options","stringToArrayBuffer","rpId","extractDomain","quidCredential","rawId","arrayBufferToString","authenticatorData","clientDataJSON","userHandle","getWebAuthnErrorMessage","createCredential","createOptions","rp","rpName","user","userId","userName","displayName","userDisplayName","pubKeyCredParams","alg","authenticatorSelection","authenticatorAttachment","requireResidentKey","attestation","isCredentialAvailable","PublicKeyCredential","isUserVerifyingPlatformAuthenticatorAvailable","cleanup","str","test","bytes","Uint8Array","length","i","parseInt","buffer","TextEncoder","encode","Array","from","byte","padStart","join","URL","hostname","errorName","errorMessage","EventEmitter","listeners","on","listener","push","index","indexOf","splice","once","unsubscribe","emit","currentListeners","console","removeAllListeners","listenerCount","Logger","prefix","setDebug","args","super","baseUrl","enableWebAuthnFallback","extensionConnector","webauthnBridge","timestamp","data","ready","extensionAvailable","createError","authRequest","generateChallenge","errorResponse","getStatus","identityCount","version","updateConfig","newConfig","Object","assign","array","crypto","getRandomValues","code","cause","details","crypto$1","isCryptoKey","key","CryptoKey","encoder","decoder","TextDecoder","decode","input","encoded","replace","binary","atob","charCodeAt","decodeBase64","TypeError","JOSEError","captureStackTrace","JWTClaimValidationFailed","payload","claim","reason","JWTExpired","JOSEAlgNotAllowed","arguments","JOSENotSupported","JWSInvalid","JWTInvalid","JWKSInvalid","JWKSNoMatchingKey","JWKSMultipleMatchingKeys","JWKSTimeout","JWSSignatureVerificationFailed","unusable","prop","isAlgorithm","algorithm","getHashLength","hash","slice","checkSigCryptoKey","usages","expected","getNamedCurve","namedCurve","some","includes","msg","last","pop","checkUsage","actual","types","filter","Boolean","invalidKeyInput","withAlg","isKeyLike","Symbol","toStringTag","isObject","value","prototype","call","getPrototypeOf","proto","isJWK","kty","parse","async","jwk","keyUsages","d","crv","subtleMapping","rest","ext","key_ops","keyData","use","subtle","importKey","exportKeyValue","k","pubCache","isKeyObject","importAndCache","cache","freeze","cached","cryptoKey","importJWK","set","normalize","export","format","dp","dq","p","q","qi","WeakMap","decodeBase64URL","oth","asKeyObject","tag","jwkMatchesOp","usage","symmetricTypeCheck","allowJwk","jwk.isJWK","jwk.isSecretJWK","checkKeyType","startsWith","jwk.isPrivateJWK","jwk.isPublicJWK","asymmetricTypeCheck","bind","checkKeyTypeWithJwk","verify","getVerifyKey","modulusLength","checkKeyLength","saltLength","subtleAlgorithm","flattenedVerify","jws","protected","header","parsedProt","protectedHeader","base64url","JSON","headers","sources","acc","parameters","keys","size","parameter","has","add","Set","isDisjoint","joseHeader","extensions","Err","recognizedDefault","recognizedOption","crit","isArray","recognized","Map","entries","validateCrit","b64","algorithms","option","s","validateAlgorithms","resolvedKey","buffers","reduce","buf","concat","result","unprotectedHeader","day","hour","REGEX","secs","matched","exec","parseFloat","numericDate","toLowerCase","round","minute","normalizeTyp","jwtPayload","encodedPayload","typ","requiredClaims","issuer","subject","audience","maxTokenAge","presenceCheck","reverse","iss","sub","audPayload","aud","audOption","tolerance","clockTolerance","currentDate","date","floor","getTime","iat","nbf","exp","age","jwtVerify","jwt","verified","split","compactVerify","isJWKLike","clone","obj","structuredClone","stringify","LocalJWKSet","jwks","_cached","every","isJWKSLike","_jwks","getKey","token","kid","getKtyFromAlg","candidates","candidate","asyncIterator","importWithAlgCache","createLocalJWKSet","localJWKSet","defineProperties","enumerable","configurable","writable","USER_AGENT","userAgent","jwksCache","RemoteJWKSet","url","cacheMaxAge","_url","href","_options","agent","_timeoutDuration","timeoutDuration","_cooldownDuration","cooldownDuration","_cacheMaxAge","_cache","uat","_jwksTimestamp","_local","coolingDown","fresh","reload","err","_pendingFetch","WebSocketPair","EdgeRuntime","Headers","fromEntries","controller","timedOut","AbortController","abort","fetch","signal","redirect","json","fetchJwks","base64url.decode","container","isLoading","element","document","querySelector","onSuccess","onError","style","buttonText","showBranding","QuIDClient","createButton","setupEventListeners","button","createElement","className","applyStyles","updateButtonContent","appendChild","width","height","backgroundColor","color","borderRadius","fontFamily","fontSize","padding","margin","border","cursor","display","alignItems","justifyContent","gap","transition","textDecoration","fontWeight","lineHeight","outline","position","overflow","transform","boxShadow","innerHTML","icon","textContent","head","handleClick","showWarning","setLoading","loading","disabled","warningElement","cssText","parentElement","removeChild","updateOptions","newOptions","destroy","getClient","QuIDSigninButton","children","props","clientRef","useRef","setIsLoading","useState","setIsReady","setExtensionAvailable","setShowWarning","useEffect","current","useCallback","authChallenge","defaultStyle","opacity","buttonContent","_jsxs","_Fragment","_jsx","borderTop","animation","onClick","background","marginTop","target","rel","jsx","useQuID","autoInit","setError","setIdentities","initClient","refreshIdentities","identityList","clearError","QuIDClient$1","quidClient","clientId","clientSecret","redirectUri","scopes","provider","authorizationEndpoint","tokenEndpoint","userInfoEndpoint","jwksEndpoint","generateAuthUrl","state","nonce","additionalParams","params","URLSearchParams","response_type","client_id","redirect_uri","scope","handleCallback","callbackUrl","searchParams","tokens","exchangeCodeForTokens","userInfo","getUserInfo","accessToken","authResponse","tokenRequest","grant_type","client_secret","quid_credential","method","Accept","body","ok","errorData","statusText","tokenData","access_token","tokenType","token_type","expiresIn","expires_in","refreshToken","refresh_token","idToken","id_token","refreshRequest","Authorization","verifyIdToken","decoded","jose.decodeJwt","remoteJWKSet","reloading","jose.createRemoteJWKSet","jose.jwtVerify","extractIssuerFromEndpoint","generateLogoutUrl","postLogoutRedirectUri","logoutEndpoint","generatePKCEChallenge","codeVerifier","base64URLEncode","digest","codeChallenge","startSecureFlow","authUrl","code_challenge","code_challenge_method","btoa","String","fromCharCode","protocol","host","getConfig"],"mappings":";;;;;;;uVAcaA,EAMX,WAAAC,CAAYC,EAAoBC,GAHzBC,KAAAC,aAAc,EAInBD,KAAKF,OAASA,EACdE,KAAKD,OAASA,EAMT,aAAMG,SACX,IAEE,GAAsB,oBAAXC,UAAwC,QAAbC,EAAAD,OAAOE,cAAM,IAAAD,OAAA,EAAAA,EAAEE,SAEnD,OADAN,KAAKD,OAAOQ,MAAM,4DACX,EAKT,UADuBP,KAAKQ,kBAG1B,OADAR,KAAKD,OAAOQ,MAAM,gCACX,EAIT,MAAME,QAAeT,KAAKU,YAAY,CAAEC,KAAM,yBAC9C,SAAIF,QAAiCG,IAAvBH,EAAOR,eACnBD,KAAKC,aAAc,EACnBD,KAAKD,OAAOc,KAAK,6CACV,GAKT,MAAOC,GAEP,OADAd,KAAKD,OAAOQ,MAAM,kCAAmCO,IAC9C,GAOJ,UAAAC,GACLf,KAAKC,aAAc,EACnBD,KAAKgB,iBAAcJ,EAMd,mBAAMK,GACX,IAAKjB,KAAKC,YACR,MAAM,IAAIiB,MAAM,2BAGlB,IACE,MAAMC,QAAiBnB,KAAKU,YAAY,CAAEC,KAAM,mBAEhD,GAAIQ,EAASC,SAAWD,EAASE,WAC/B,OAAOF,EAASE,WAAWC,IAAItB,KAAKuB,aAEpC,MAAM,IAAIL,MAAMC,EAASL,OAAS,4BAEpC,MAAOA,GAEP,MADAd,KAAKD,OAAOe,MAAM,2CAA4CA,GACxDA,GAOH,oBAAMU,CAAeC,GAC1B,IAAKzB,KAAKC,YACR,MAAM,IAAIiB,MAAM,2BAGlB,IACE,MAAMC,QAAiBnB,KAAKU,YAAY,CACtCC,KAAM,kBACNb,OAAQ,CACN4B,KAAMD,EAAQC,KACdC,cAAeF,EAAQE,eAAiB,SACxCC,SAAUH,EAAQG,UAAY,CAAC,UAInC,GAAIT,EAASC,SAAWD,EAASU,SAC/B,OAAO7B,KAAKuB,YAAYJ,EAASU,UAEjC,MAAM,IAAIX,MAAMC,EAASL,OAAS,6BAEpC,MAAOA,GAEP,MADAd,KAAKD,OAAOe,MAAM,2CAA4CA,GACxDA,GAOH,kBAAMgB,CAAaL,GACxB,IAAKzB,KAAKC,YACR,MAAM,IAAIiB,MAAM,2BAGlB,IACE,MAAMC,QAAiBnB,KAAKU,YAAY,CACtCC,KAAM,eACNoB,UAAWN,EAAQM,UACnBC,iBAAkBP,EAAQO,iBAC1BC,iBAAkBR,EAAQQ,iBAC1BC,QAAST,EAAQS,UAGnB,MAAO,CACLd,QAASD,EAASC,UAAW,EAC7BN,MAAOK,EAASL,MAChBqB,WAAYhB,EAASgB,WACrBN,SAAUV,EAASU,SAAW7B,KAAKuB,YAAYJ,EAASU,eAAYjB,GAGtE,MAAOE,GAEP,OADAd,KAAKD,OAAOe,MAAM,uCAAwCA,GACnD,CACLM,SAAS,EACTN,MAAOA,aAAiBI,MAAQJ,EAAMsB,QAAU,0BAQ/C,mBAAMC,CAAcC,EAAoBP,GAC7C,IAAK/B,KAAKC,YACR,MAAM,IAAIiB,MAAM,2BAGlB,IACE,MAAMC,QAAiBnB,KAAKU,YAAY,CACtCC,KAAM,iBACN2B,aACAP,YACAQ,OAAQpC,OAAOqC,SAASD,SAG1B,GAAIpB,EAASC,SAAWD,EAASsB,UAC/B,OAAOtB,EAASsB,UAEhB,MAAM,IAAIvB,MAAMC,EAASL,OAAS,4BAEpC,MAAOA,GAEP,MADAd,KAAKD,OAAOe,MAAM,0CAA2CA,GACvDA,GAOF,qBAAMN,GACZ,IAEE,OAAIL,OAAOuC,MAAQvC,OAAOuC,KAAKC,aAC7B3C,KAAKD,OAAOQ,MAAM,8BACX,GAIF,IAAIqC,QAASC,IAClB,MAAMX,EAAUY,WAAW,IAAMD,GAAQ,GAAQ,KAE3CE,EAAWC,IACXA,EAAMC,QAAUD,EAAMC,OAAOC,YAC/BC,aAAajB,GACb/B,OAAOiD,oBAAoB,aAAcL,GACzCF,GAAQ,KAIZ1C,OAAOkD,iBAAiB,aAAcN,GAGtC5C,OAAOmD,cAAc,IAAIC,YAAY,kBAGvC,MAAOzC,GAEP,OADAd,KAAKD,OAAOQ,MAAM,8BAA+BO,IAC1C,GAOH,iBAAMJ,CAAY0B,GACxB,OAAO,IAAIQ,QAAQ,CAACC,EAASW,WAC3B,MAAMtB,EAAUY,WAAW,KACzBU,EAAO,IAAItC,MAAM,+BAChBlB,KAAKF,OAAOoC,SAAW,KAE1B,IAEE,GAAIlC,KAAKgB,cAA4B,QAAbZ,EAAAD,OAAOE,cAAM,IAAAD,OAAA,EAAAA,EAAEE,SASrC,YARAH,OAAOE,OAAOC,QAAQI,YAAYV,KAAKgB,YAAaoB,EAAUjB,IAC5DgC,aAAajB,GACT/B,OAAOE,OAAOC,QAAQmD,UACxBD,EAAO,IAAItC,MAAMf,OAAOE,OAAOC,QAAQmD,UAAUrB,UAEjDS,EAAQ1B,KAOd,GAAIhB,OAAOuC,KAET,YADA1C,KAAK0D,qBAAqBtB,EAASS,EAASW,EAAQtB,GAKtDlC,KAAK2D,yBAAyBvB,EAASS,EAASW,EAAQtB,GAExD,MAAOpB,GACPqC,aAAajB,GACbsB,EAAO1C,MAQL,oBAAA4C,CAAqBtB,EAAcS,EAAmBW,EAAkBtB,GAC9E,IACE,OAAQE,EAAQzB,MACd,IAAK,uBACHR,OAAOuC,KAAKkB,UAAUC,KAAKhB,GAASiB,MAAMN,GAC1C,MAEF,IAAK,iBACHrD,OAAOuC,KAAKzB,gBAAgB4C,KAAKhB,GAASiB,MAAMN,GAChD,MAEF,IAAK,eACHrD,OAAOuC,KAAKZ,aAAa,CACvBC,UAAWK,EAAQL,UACnBE,iBAAkBG,EAAQH,iBAC1BC,QAASE,EAAQF,QACjBF,iBAAkBI,EAAQJ,mBACzB6B,KAAKhB,GAASiB,MAAMN,GACvB,MAEF,IAAK,kBACHrD,OAAOuC,KAAKlB,eAAeY,EAAQtC,QAAQ+D,KAAKhB,GAASiB,MAAMN,GAC/D,MAEF,IAAK,iBACHrD,OAAOuC,KAAKL,cAAcD,EAAQE,WAAYF,EAAQL,WACnD8B,KAAKpB,GAAaI,EAAQ,CAAEzB,SAAS,EAAMqB,eAC3CqB,MAAMN,GACT,MAEF,QACEA,EAAO,IAAItC,MAAM,0BAErB,MAAOJ,GACPqC,aAAajB,GACbsB,EAAO1C,IAOH,wBAAA6C,CAAyBvB,EAAcS,EAAmBW,EAAkBtB,GAClF,MAAM6B,EAAY,QAAQC,KAAKC,SAASC,KAAKC,SAASC,SAAS,IAAIC,OAAO,EAAG,KAEvEtB,EAAWC,IACXA,EAAMC,QAAUD,EAAMC,OAAOc,YAAcA,IAC7CZ,aAAajB,GACb/B,OAAOiD,oBAAoB,gBAAiBL,GAC5CF,EAAQG,EAAMC,OAAO9B,YAIzBhB,OAAOkD,iBAAiB,gBAAiBN,GAEzC5C,OAAOmD,cAAc,IAAIC,YAAY,eAAgB,CACnDN,OAAQ,IAAKb,EAAS2B,gBAOlB,WAAAxC,CAAY+C,GAClB,MAAO,CACLC,GAAID,EAAYC,GAChB7C,KAAM4C,EAAY5C,KAClBC,cAAe2C,EAAYE,gBAAkBF,EAAY3C,eAAiB,SAC1EC,SAAU0C,EAAY1C,UAAY,CAAC,OACnC6C,UAAoC,IAA1BH,EAAYI,UACtBC,UAAW,IAAIX,KAAKM,EAAYM,YAAcN,EAAYK,WAAaX,KAAKC,OAC5EY,WAAYP,EAAYQ,cAAgBR,EAAYO,WAClD,IAAIb,KAAKM,EAAYQ,cAAgBR,EAAYO,iBAAcjE,EACjEmE,UAAWT,EAAYU,YAAcV,EAAYS,kBC3T1CE,EAIX,WAAApF,CAAYqF,EAAanF,GACvBC,KAAKkF,OAASA,EACdlF,KAAKD,OAASA,EAMT,IAAAoF,GACAnF,KAAKoF,sBAKVpF,KAAKD,OAAOQ,MAAM,+BAJhBP,KAAKD,OAAOsF,KAAK,6CAUd,mBAAAD,GACL,SAAUE,UAAUC,aAAeD,UAAUC,YAAYC,QAAUF,UAAUC,YAAYE,KAMpF,kBAAM3D,CAAaL,GACxB,IAAKzB,KAAKoF,sBACR,MAAO,CACLhE,SAAS,EACTN,MAAO,6CAIX,IACEd,KAAKD,OAAOQ,MAAM,6CAElB,MAAMmF,EAA4C,CAChDX,UAAW,CACThD,UAAW/B,KAAK2F,oBAAoBlE,EAAQM,WAC5CG,QAAST,EAAQS,QACjB0D,KAAMnE,EAAQmE,MAAQ5F,KAAK6F,cAAcpE,EAAQc,QACjDP,iBAAkBP,EAAQO,kBAAoB,GAC9CC,iBAAkBR,EAAQQ,kBAAoB,cAI5CE,QAAmBmD,UAAUC,YAAYE,IAAIC,GAEnD,IAAKvD,EACH,MAAO,CACLf,SAAS,EACTN,MAAO,wCAIX,MAAMK,EAAWgB,EAAWhB,SAEtB2E,EAAiC,CACrCvB,GAAIpC,EAAWoC,GACfwB,MAAO/F,KAAKgG,oBAAoB7D,EAAW4D,OAC3CpF,KAAM,aACNQ,SAAU,CACR8E,kBAAmBjG,KAAKgG,oBAAoB7E,EAAS8E,mBACrDC,eAAgBlG,KAAKgG,oBAAoB7E,EAAS+E,gBAClDzD,UAAWzC,KAAKgG,oBAAoB7E,EAASsB,WAC7C0D,WAAYhF,EAASgF,WAAanG,KAAKgG,oBAAoB7E,EAASgF,iBAAcvF,IAMtF,OAFAZ,KAAKD,OAAOc,KAAK,+CAEV,CACLO,SAAS,EACTe,WAAY2D,GAGd,MAAOhF,GAGP,OAFAd,KAAKD,OAAOe,MAAM,2CAA4CA,GAEvD,CACLM,SAAS,EACTN,MAAOd,KAAKoG,wBAAwBtF,KAQnC,sBAAMuF,CAAiBX,GAS5B,IAAK1F,KAAKoF,sBACR,MAAO,CACLhE,SAAS,EACTN,MAAO,6CAIX,IACEd,KAAKD,OAAOQ,MAAM,gCAElB,MAAM+F,EAA2C,CAC/CvB,UAAW,CACThD,UAAW/B,KAAK2F,oBAAoBD,EAAQ3D,WAC5CwE,GAAI,CACF7E,KAAMgE,EAAQc,OACdjC,GAAImB,EAAQE,MAAQ5F,KAAK6F,cAAc1F,OAAOqC,SAASD,SAEzDkE,KAAM,CACJlC,GAAIvE,KAAK2F,oBAAoBD,EAAQgB,QACrChF,KAAMgE,EAAQiB,SACdC,YAAalB,EAAQmB,iBAEvBC,iBAAkB,CAChB,CAAEC,KAAM,EAAGpG,KAAM,cACjB,CAAEoG,KAAM,IAAKpG,KAAM,eAErBuB,QAASwD,EAAQxD,SAAW,IAC5B8E,uBAAwB,CACtBC,wBAAyB,WACzBhF,iBAAkB,YAClBiF,oBAAoB,GAEtBC,YAAa,WAIXhF,QAAmBmD,UAAUC,YAAYC,OAAOc,GAEtD,IAAKnE,EACH,MAAO,CACLf,SAAS,EACTN,MAAO,yBAIX,MAAMK,EAAWgB,EAAWhB,SAEtB2E,EAAiC,CACrCvB,GAAIpC,EAAWoC,GACfwB,MAAO/F,KAAKgG,oBAAoB7D,EAAW4D,OAC3CpF,KAAM,aACNQ,SAAU,CACR8E,kBAAmBjG,KAAKgG,oBAAoB7E,EAAS8E,mBACrDC,eAAgBlG,KAAKgG,oBAAoB7E,EAAS+E,gBAClDzD,UAAW,GACX0D,gBAAYvF,IAMhB,OAFAZ,KAAKD,OAAOc,KAAK,4CAEV,CACLO,SAAS,EACTe,WAAY2D,GAGd,MAAOhF,GAGP,OAFAd,KAAKD,OAAOe,MAAM,uCAAwCA,GAEnD,CACLM,SAAS,EACTN,MAAOd,KAAKoG,wBAAwBtF,KAQnC,2BAAMsG,GACX,IAAKpH,KAAKoF,sBACR,OAAO,EAGT,IAGE,aADwBiC,oBAAoBC,gDAE5C,MAAOxG,GAEP,OADAd,KAAKD,OAAOQ,MAAM,2CAA4CO,IACvD,GAOJ,OAAAyG,GAELvH,KAAKD,OAAOQ,MAAM,8BAMZ,mBAAAoF,CAAoB6B,GAE1B,GAAI,iBAAiBC,KAAKD,GAAM,CAC9B,MAAME,EAAQ,IAAIC,WAAWH,EAAII,OAAS,GAC1C,IAAK,IAAIC,EAAI,EAAGA,EAAIL,EAAII,OAAQC,GAAK,EACnCH,EAAMG,EAAI,GAAKC,SAASN,EAAInD,OAAOwD,EAAG,GAAI,IAE5C,OAAOH,EAAMK,OAKf,OADgB,IAAIC,aACLC,OAAOT,GAAKO,OAMrB,mBAAA/B,CAAoB+B,GAC1B,MAAML,EAAQ,IAAIC,WAAWI,GAC7B,OAAOG,MAAMC,KAAKT,EAAOU,GAAQA,EAAKhE,SAAS,IAAIiE,SAAS,EAAG,MAAMC,KAAK,IAMpE,aAAAzC,CAActD,GACpB,IAEE,OADY,IAAIgG,IAAIhG,GACTiG,SACX,MAAO1H,GAEP,OADAd,KAAKD,OAAOsF,KAAK,wCAAyC9C,GACnD,aAOH,uBAAA6D,CAAwBtF,GAC9B,IAAKA,EAAO,MAAO,yBAEnB,MAAM2H,EAAY3H,EAAMY,MAAQ,GAC1BgH,EAAe5H,EAAMsB,SAAW,GAEtC,OAAQqG,GACN,IAAK,kBACH,MAAO,8CACT,IAAK,gBACH,MAAO,uCACT,IAAK,oBACH,MAAO,2CACT,IAAK,oBACH,MAAO,uCACT,IAAK,kBACH,MAAO,8CACT,IAAK,eACH,MAAO,kDACT,QACE,OAAOC,GAAgB,yCClRlBC,EAAb,WAAA9I,GACUG,KAAA4I,UAAgC,GAKjC,EAAAC,CAAGC,GAIR,OAHA9I,KAAK4I,UAAUG,KAAKD,GAGb,KACL,MAAME,EAAQhJ,KAAK4I,UAAUK,QAAQH,GACjCE,GAAQ,GACVhJ,KAAK4I,UAAUM,OAAOF,EAAO,IAQ5B,IAAAG,CAAKL,GACV,MAKMM,EAAcpJ,KAAK6I,GALe7F,IACtC8F,EAAS9F,GACToG,MAIF,OAAOA,EAMF,IAAAC,CAAKrG,GAEV,MAAMsG,EAAmB,IAAItJ,KAAK4I,WAElC,IAAK,MAAME,KAAYQ,EACrB,IACER,EAAS9F,GACT,MAAOlC,GACPyI,QAAQzI,MAAM,2BAA4BA,IAQzC,kBAAA0I,GACLxJ,KAAK4I,UAAY,GAMnB,iBAAWa,GACT,OAAOzJ,KAAK4I,UAAUhB,cC5Db8B,EAIX,WAAA7J,CAAYU,GAAQ,GAFZP,KAAA2J,OAAS,aAGf3J,KAAKO,MAAQA,EAMR,QAAAqJ,CAASrJ,GACdP,KAAKO,MAAQA,EAMR,KAAAA,CAAM6B,KAAoByH,GAC3B7J,KAAKO,OACPgJ,QAAQhJ,MAAMP,KAAK2J,OAAQvH,KAAYyH,GAOpC,IAAAhJ,CAAKuB,KAAoByH,GAC1B7J,KAAKO,OACPgJ,QAAQ1I,KAAKb,KAAK2J,OAAQvH,KAAYyH,GAOnC,IAAAxE,CAAKjD,KAAoByH,GAC9BN,QAAQlE,KAAKrF,KAAK2J,OAAQvH,KAAYyH,GAMjC,KAAA/I,CAAMsB,KAAoByH,GAC/BN,QAAQzI,MAAMd,KAAK2J,OAAQvH,KAAYyH,UC7BrC,cAA0BlB,EAO9B,WAAA9I,CAAYC,EAAqB,IAC/BgK,QAHM9J,KAAA4D,SAAU,EAKhB5D,KAAKF,OAAS,CACZiK,QAAS,GACT7H,QAAS,IACTD,iBAAkB,YAClB1B,OAAO,EACPS,YAAa,GACbgJ,wBAAwB,KACrBlK,GAGLE,KAAKD,OAAS,IAAI2J,EAAO1J,KAAKF,OAAOS,OACrCP,KAAKiK,mBAAqB,IAAIrK,EAAmBI,KAAKF,OAAQE,KAAKD,QACnEC,KAAKkK,eAAiB,IAAIjF,EAAejF,KAAMA,KAAKD,QAEpDC,KAAKmF,OAGC,UAAMA,GACZ,IACEnF,KAAKD,OAAOQ,MAAM,qCAGeP,KAAKiK,mBAAmB/J,WAGvDF,KAAKD,OAAOc,KAAK,uCACjBb,KAAKqJ,KAAK,CACR1I,KAAM,sBACNwJ,UAAW,IAAInG,SAGjBhE,KAAKD,OAAOsF,KAAK,wCAEbrF,KAAKF,OAAOkK,wBACdhK,KAAKD,OAAOc,KAAK,8BAKrBb,KAAKkK,eAAe/E,OAEpBnF,KAAK4D,SAAU,EACf5D,KAAKqJ,KAAK,CACR1I,KAAM,QACNwJ,UAAW,IAAInG,OAGjBhE,KAAKD,OAAOc,KAAK,qBAEjB,MAAOC,GACPd,KAAKD,OAAOe,MAAM,oCAAqCA,GACvDd,KAAKqJ,KAAK,CACR1I,KAAM,QACNyJ,KAAMtJ,EACNqJ,UAAW,IAAInG,QAQrB,SAAWqG,GACT,OAAOrK,KAAK4D,QAMd,sBAAW0G,GACT,OAAOtK,KAAKiK,mBAAmBhK,YAM1B,mBAAMgB,GACX,IAAKjB,KAAK4D,QACR,MAAM5D,KAAKuK,YAAY,gBAAiB,yBAG1C,IACE,OAAIvK,KAAKiK,mBAAmBhK,kBACbD,KAAKiK,mBAAmBhJ,iBAErCjB,KAAKD,OAAOsF,KAAK,yDACV,IAET,MAAOvE,GAEP,MADAd,KAAKD,OAAOe,MAAM,4BAA6BA,GACzCd,KAAKuK,YAAY,wBAAyB,gCAAiCzJ,IAO9E,oBAAMU,CAAeC,GAC1B,IAAKzB,KAAK4D,QACR,MAAM5D,KAAKuK,YAAY,gBAAiB,yBAG1C,IAAKvK,KAAKiK,mBAAmBhK,YAC3B,MAAMD,KAAKuK,YAAY,0BAA2B,4DAGpD,IACEvK,KAAKD,OAAOQ,MAAM,yBAA0BkB,GAE5C,MAAMI,QAAiB7B,KAAKiK,mBAAmBzI,eAAeC,GAS9D,OAPAzB,KAAKqJ,KAAK,CACR1I,KAAM,mBACNyJ,KAAMvI,EACNsI,UAAW,IAAInG,OAGjBhE,KAAKD,OAAOc,KAAK,iCAAkCgB,EAAS0C,IACrD1C,EAEP,MAAOf,GAEP,MADAd,KAAKD,OAAOe,MAAM,6BAA8BA,GAC1Cd,KAAKuK,YAAY,yBAA0B,4BAA6BzJ,IAO3E,kBAAMgB,CAAaL,EAA0C,IAClE,IAAKzB,KAAK4D,QACR,MAAM5D,KAAKuK,YAAY,gBAAiB,yBAG1C,MAAMC,EAAqC,CACzCzI,UAAWN,EAAQM,WAAa/B,KAAKyK,oBACrClI,OAAQd,EAAQc,QAAUpC,OAAOqC,SAASD,OAC1CN,iBAAkBR,EAAQQ,kBAAoBjC,KAAKF,OAAOmC,iBAC1DC,QAAST,EAAQS,SAAWlC,KAAKF,OAAOoC,QACxCF,iBAAkBP,EAAQO,iBAC1B4D,KAAMnE,EAAQmE,MAGhB5F,KAAKqJ,KAAK,CACR1I,KAAM,yBACNyJ,KAAMI,EACNL,UAAW,IAAInG,OAGjB,IAGE,IAAI7C,EAEJ,GAJAnB,KAAKD,OAAOQ,MAAM,2BAA4BiK,GAI1CxK,KAAKiK,mBAAmBhK,YAE1BkB,QAAiBnB,KAAKiK,mBAAmBnI,aAAa0I,OACjD,KAAIxK,KAAKF,OAAOkK,yBAA0B1E,UAAUC,YAKzD,MAAMvF,KAAKuK,YAAY,iBAAkB,sCAHzCvK,KAAKD,OAAOc,KAAK,2BACjBM,QAAiBnB,KAAKkK,eAAepI,aAAa0I,GAqBpD,OAhBIrJ,EAASC,SACXpB,KAAKqJ,KAAK,CACR1I,KAAM,2BACNyJ,KAAMjJ,EACNgJ,UAAW,IAAInG,OAEjBhE,KAAKD,OAAOc,KAAK,+BAEjBb,KAAKqJ,KAAK,CACR1I,KAAM,wBACNyJ,KAAMjJ,EACNgJ,UAAW,IAAInG,OAEjBhE,KAAKD,OAAOsF,KAAK,yBAA0BlE,EAASL,QAG/CK,EAEP,MAAOL,GACPd,KAAKD,OAAOe,MAAM,wBAAyBA,GAE3C,MAAM4J,EAAwC,CAC5CtJ,SAAS,EACTN,MAAOA,aAAiBI,MAAQJ,EAAMsB,QAAU,gCASlD,OANApC,KAAKqJ,KAAK,CACR1I,KAAM,wBACNyJ,KAAMM,EACNP,UAAW,IAAInG,OAGV0G,GAOJ,mBAAMrI,CAAcC,EAAoBP,GAC7C,IAAK/B,KAAK4D,QACR,MAAM5D,KAAKuK,YAAY,gBAAiB,yBAG1C,IAAKvK,KAAKiK,mBAAmBhK,YAC3B,MAAMD,KAAKuK,YAAY,0BAA2B,kDAGpD,IACEvK,KAAKD,OAAOQ,MAAM,qBAAsB,CAAE+B,aAAYP,cAEtD,MAAMU,QAAkBzC,KAAKiK,mBAAmB5H,cAAcC,EAAYP,GAG1E,OADA/B,KAAKD,OAAOc,KAAK,iCACV4B,EAEP,MAAO3B,GAEP,MADAd,KAAKD,OAAOe,MAAM,4BAA6BA,GACzCd,KAAKuK,YAAY,wBAAyB,2BAA4BzJ,IAOzE,eAAM6J,GAMX,MAAMtJ,EAAarB,KAAKsK,yBAA2BtK,KAAKiB,gBAAkB,GAE1E,MAAO,CACLoJ,MAAOrK,KAAK4D,QACZ0G,mBAAoBtK,KAAKsK,mBACzBM,cAAevJ,EAAWuG,OAC1BiD,QAAS,SAON,YAAAC,CAAaC,GAClBC,OAAOC,OAAOjL,KAAKF,OAAQiL,GAC3B/K,KAAKD,OAAO6J,SAAS5J,KAAKF,OAAOS,OACjCP,KAAKD,OAAOQ,MAAM,yBAA0BwK,GAMvC,UAAAhK,GACLf,KAAKD,OAAOQ,MAAM,6BAElBP,KAAKiK,mBAAmBlJ,aACxBf,KAAKkK,eAAe3C,UACpBvH,KAAK4D,SAAU,EAEf5D,KAAKqJ,KAAK,CACR1I,KAAM,yBACNwJ,UAAW,IAAInG,OAIX,iBAAAyG,GACN,MAAMS,EAAQ,IAAIvD,WAAW,IAE7B,OADAwD,OAAOC,gBAAgBF,GAChBhD,MAAMC,KAAK+C,EAAO9C,GAAQA,EAAKhE,SAAS,IAAIiE,SAAS,EAAG,MAAMC,KAAK,IAGpE,WAAAiC,CAAYc,EAAcjJ,EAAiBkJ,GACjD,MAAMxK,EAAQ,IAAII,MAAMkB,GAIxB,OAHAtB,EAAMY,KAAO,eACbZ,EAAMuK,KAAOA,EACbvK,EAAMyK,QAAUD,EACTxK,ICxTX,IAAA0K,EAAeL,OACR,MAAMM,EAAeC,GAAQA,aAAeC,UCAtCC,EAAU,IAAI5D,YACd6D,EAAU,IAAIC,YCcpB,MAQMC,EAAUC,IACnB,IAAIC,EAAUD,EACVC,aAAmBtE,aACnBsE,EAAUJ,EAAQE,OAAOE,IAE7BA,EAAUA,EAAQC,QAAQ,KAAM,KAAKA,QAAQ,KAAM,KAAKA,QAAQ,MAAO,IACvE,IACI,MAfoB,CAACD,IACzB,MAAME,EAASC,KAAKH,GACdvE,EAAQ,IAAIC,WAAWwE,EAAOvE,QACpC,IAAK,IAAIC,EAAI,EAAGA,EAAIsE,EAAOvE,OAAQC,IAC/BH,EAAMG,GAAKsE,EAAOE,WAAWxE,GAEjC,OAAOH,GASI4E,CAAaL,EAC5B,CACI,MACI,MAAM,IAAIM,UAAU,oDAC5B,GCnCO,MAAMC,UAAkBtL,MAC3B,WAAArB,CAAYuC,EAASsD,GACjBoE,MAAM1H,EAASsD,GACf1F,KAAKqL,KAAO,mBACZrL,KAAK0B,KAAO1B,KAAKH,YAAY6B,KAC7BR,MAAMuL,oBAAoBzM,KAAMA,KAAKH,YAC7C,EAEA2M,EAAUnB,KAAO,mBACV,MAAMqB,UAAiCF,EAC1C,WAAA3M,CAAYuC,EAASuK,EAASC,EAAQ,cAAeC,EAAS,eAC1D/C,MAAM1H,EAAS,CAAEkJ,MAAO,CAAEsB,QAAOC,SAAQF,aACzC3M,KAAKqL,KAAO,kCACZrL,KAAK4M,MAAQA,EACb5M,KAAK6M,OAASA,EACd7M,KAAK2M,QAAUA,CACvB,EAEAD,EAAyBrB,KAAO,kCACzB,MAAMyB,UAAmBN,EAC5B,WAAA3M,CAAYuC,EAASuK,EAASC,EAAQ,cAAeC,EAAS,eAC1D/C,MAAM1H,EAAS,CAAEkJ,MAAO,CAAEsB,QAAOC,SAAQF,aACzC3M,KAAKqL,KAAO,kBACZrL,KAAK4M,MAAQA,EACb5M,KAAK6M,OAASA,EACd7M,KAAK2M,QAAUA,CACvB,EAEAG,EAAWzB,KAAO,kBACX,MAAM0B,UAA0BP,EACnC,WAAA3M,GACIiK,SAASkD,WACThN,KAAKqL,KAAO,0BACpB,EAEA0B,EAAkB1B,KAAO,2BAClB,MAAM4B,UAAyBT,EAClC,WAAA3M,GACIiK,SAASkD,WACThN,KAAKqL,KAAO,wBACpB,EAEA4B,EAAiB5B,KAAO,0BACjB,cAAkCmB,EACrC,WAAA3M,CAAYuC,EAAU,8BAA+BsD,GACjDoE,MAAM1H,EAASsD,GACf1F,KAAKqL,KAAO,2BACpB,IAEoBA,KAAO,6BACpB,cAAyBmB,EAC5B,WAAA3M,GACIiK,SAASkD,WACThN,KAAKqL,KAAO,iBACpB,IAEWA,KAAO,kBACX,MAAM6B,UAAmBV,EAC5B,WAAA3M,GACIiK,SAASkD,WACThN,KAAKqL,KAAO,iBACpB,EAEA6B,EAAW7B,KAAO,kBACX,MAAM8B,UAAmBX,EAC5B,WAAA3M,GACIiK,SAASkD,WACThN,KAAKqL,KAAO,iBACpB,EAEA8B,EAAW9B,KAAO,mBACX,cAAyBmB,EAC5B,WAAA3M,GACIiK,SAASkD,WACThN,KAAKqL,KAAO,iBACpB,IAEWA,KAAO,kBACX,MAAM+B,UAAoBZ,EAC7B,WAAA3M,GACIiK,SAASkD,WACThN,KAAKqL,KAAO,kBACpB,EAEA+B,EAAY/B,KAAO,mBACZ,MAAMgC,UAA0Bb,EACnC,WAAA3M,CAAYuC,EAAU,kDAAmDsD,GACrEoE,MAAM1H,EAASsD,GACf1F,KAAKqL,KAAO,0BACpB,EAEAgC,EAAkBhC,KAAO,2BAClB,MAAMiC,UAAiCd,EAC1C,WAAA3M,CAAYuC,EAAU,uDAAwDsD,GAC1EoE,MAAM1H,EAASsD,GACf1F,KAAKqL,KAAO,iCACpB,EAGAiC,EAAyBjC,KAAO,kCACzB,MAAMkC,UAAoBf,EAC7B,WAAA3M,CAAYuC,EAAU,oBAAqBsD,GACvCoE,MAAM1H,EAASsD,GACf1F,KAAKqL,KAAO,kBACpB,EAEAkC,EAAYlC,KAAO,mBACZ,MAAMmC,UAAuChB,EAChD,WAAA3M,CAAYuC,EAAU,gCAAiCsD,GACnDoE,MAAM1H,EAASsD,GACf1F,KAAKqL,KAAO,uCACpB,EC/GA,SAASoC,EAAS/L,EAAMgM,EAAO,kBAC3B,OAAO,IAAInB,UAAU,kDAAkDmB,aAAgBhM,IAC3F,CACA,SAASiM,EAAYC,EAAWlM,GAC5B,OAAOkM,EAAUlM,OAASA,CAC9B,CACA,SAASmM,EAAcC,GACnB,OAAOhG,SAASgG,EAAKpM,KAAKqM,MAAM,GAAI,GACxC,CA6BO,SAASC,EAAkBtC,EAAK3E,KAAQkH,GAC3C,OAAQlH,GACJ,IAAK,QACL,IAAK,QACL,IAAK,QAAS,CACV,IAAK4G,EAAYjC,EAAIkC,UAAW,QAC5B,MAAMH,EAAS,QACnB,MAAMS,EAAWpG,SAASf,EAAIgH,MAAM,GAAI,IAExC,GADeF,EAAcnC,EAAIkC,UAAUE,QAC5BI,EACX,MAAMT,EAAS,OAAOS,IAAY,kBACtC,KACZ,CACQ,IAAK,QACL,IAAK,QACL,IAAK,QAAS,CACV,IAAKP,EAAYjC,EAAIkC,UAAW,qBAC5B,MAAMH,EAAS,qBACnB,MAAMS,EAAWpG,SAASf,EAAIgH,MAAM,GAAI,IAExC,GADeF,EAAcnC,EAAIkC,UAAUE,QAC5BI,EACX,MAAMT,EAAS,OAAOS,IAAY,kBACtC,KACZ,CACQ,IAAK,QACL,IAAK,QACL,IAAK,QAAS,CACV,IAAKP,EAAYjC,EAAIkC,UAAW,WAC5B,MAAMH,EAAS,WACnB,MAAMS,EAAWpG,SAASf,EAAIgH,MAAM,GAAI,IAExC,GADeF,EAAcnC,EAAIkC,UAAUE,QAC5BI,EACX,MAAMT,EAAS,OAAOS,IAAY,kBACtC,KACZ,CACQ,IAAK,QACD,GAA2B,YAAvBxC,EAAIkC,UAAUlM,MAA6C,UAAvBgK,EAAIkC,UAAUlM,KAClD,MAAM+L,EAAS,oBAEnB,MAEJ,IAAK,UACD,IAAKE,EAAYjC,EAAIkC,UAAW,WAC5B,MAAMH,EAAS,WACnB,MAEJ,IAAK,QACL,IAAK,QACL,IAAK,QAAS,CACV,IAAKE,EAAYjC,EAAIkC,UAAW,SAC5B,MAAMH,EAAS,SACnB,MAAMS,EA/ElB,SAAuBnH,GACnB,OAAQA,GACJ,IAAK,QACD,MAAO,QACX,IAAK,QACD,MAAO,QACX,IAAK,QACD,MAAO,QACX,QACI,MAAM,IAAI7F,MAAM,eAE5B,CAoE6BiN,CAAcpH,GAE/B,GADe2E,EAAIkC,UAAUQ,aACdF,EACX,MAAMT,EAASS,EAAU,wBAC7B,KACZ,CACQ,QACI,MAAM,IAAI3B,UAAU,8CA1EhC,SAAoBb,EAAKuC,GACrB,GAAIA,EAAOrG,SAAWqG,EAAOI,KAAMH,GAAaxC,EAAIuC,OAAOK,SAASJ,IAAY,CAC5E,IAAIK,EAAM,sEACV,GAAIN,EAAOrG,OAAS,EAAG,CACnB,MAAM4G,EAAOP,EAAOQ,MACpBF,GAAO,UAAUN,EAAO3F,KAAK,aAAakG,IACtD,MACmC,IAAlBP,EAAOrG,OACZ2G,GAAO,UAAUN,EAAO,SAASA,EAAO,MAGxCM,GAAO,GAAGN,EAAO,MAErB,MAAM,IAAI1B,UAAUgC,EAC5B,CACA,CA6DIG,CAAWhD,EAAKuC,EACpB,CClGA,SAAS7L,EAAQmM,EAAKI,KAAWC,GAE7B,IADAA,EAAQA,EAAMC,OAAOC,UACXlH,OAAS,EAAG,CAClB,MAAM4G,EAAOI,EAAMH,MACnBF,GAAO,eAAeK,EAAMtG,KAAK,aAAakG,IACtD,MAC8B,IAAjBI,EAAMhH,OACX2G,GAAO,eAAeK,EAAM,SAASA,EAAM,MAG3CL,GAAO,WAAWK,EAAM,MAa5B,OAXc,MAAVD,EACAJ,GAAO,aAAaI,IAEG,mBAAXA,GAAyBA,EAAOjN,KAC5C6M,GAAO,sBAAsBI,EAAOjN,OAEb,iBAAXiN,GAAiC,MAAVA,GAC/BA,EAAO9O,aAAa6B,OACpB6M,GAAO,4BAA4BI,EAAO9O,YAAY6B,QAGvD6M,CACX,CFyFAf,EAA+BnC,KAAO,wCExFtC,IAAA0D,EAAe,CAACJ,KAAWC,IAChBxM,EAAQ,eAAgBuM,KAAWC,GAEvC,SAASI,EAAQjI,EAAK4H,KAAWC,GACpC,OAAOxM,EAAQ,eAAe2E,uBAA0B4H,KAAWC,EACvE,CC7BA,IAAAK,EAAgBvD,KACRD,EAAYC,IAGqB,cAA9BA,IAAMwD,OAAOC,aAEjB,MAAMP,EAAQ,CAAC,aCJP,SAASQ,EAASpD,GAC7B,GAHwB,iBADNqD,EAIArD,IAH4B,OAAVqD,GAGkC,oBAA1CrE,OAAOsE,UAAUlL,SAASmL,KAAKvD,GACvD,OAAO,EALf,IAAsBqD,EAOlB,GAAqC,OAAjCrE,OAAOwE,eAAexD,GACtB,OAAO,EAEX,IAAIyD,EAAQzD,EACZ,KAAwC,OAAjChB,OAAOwE,eAAeC,IACzBA,EAAQzE,OAAOwE,eAAeC,GAElC,OAAOzE,OAAOwE,eAAexD,KAAWyD,CAC5C,CCdO,SAASC,EAAMhE,GAClB,OAAO0D,EAAS1D,IAA2B,iBAAZA,EAAIiE,GACvC,CCqFA,MAAMC,EAAQC,MAAOC,IACjB,IAAKA,EAAI/I,IACL,MAAM,IAAIwF,UAAU,4DAExB,MAAMqB,UAAEA,EAASmC,UAAEA,GA1FvB,SAAuBD,GACnB,IAAIlC,EACAmC,EACJ,OAAQD,EAAIH,KACR,IAAK,MACD,OAAQG,EAAI/I,KACR,IAAK,QACL,IAAK,QACL,IAAK,QACD6G,EAAY,CAAElM,KAAM,UAAWoM,KAAM,OAAOgC,EAAI/I,IAAIgH,OAAM,MAC1DgC,EAAYD,EAAIE,EAAI,CAAC,QAAU,CAAC,UAChC,MACJ,IAAK,QACL,IAAK,QACL,IAAK,QACDpC,EAAY,CAAElM,KAAM,oBAAqBoM,KAAM,OAAOgC,EAAI/I,IAAIgH,OAAM,MACpEgC,EAAYD,EAAIE,EAAI,CAAC,QAAU,CAAC,UAChC,MACJ,IAAK,WACL,IAAK,eACL,IAAK,eACL,IAAK,eACDpC,EAAY,CACRlM,KAAM,WACNoM,KAAM,OAAOhG,SAASgI,EAAI/I,IAAIgH,UAAW,KAAO,KAEpDgC,EAAYD,EAAIE,EAAI,CAAC,UAAW,aAAe,CAAC,UAAW,WAC3D,MACJ,QACI,MAAM,IAAI/C,EAAiB,gEAEnC,MAEJ,IAAK,KACD,OAAQ6C,EAAI/I,KACR,IAAK,QACD6G,EAAY,CAAElM,KAAM,QAAS0M,WAAY,SACzC2B,EAAYD,EAAIE,EAAI,CAAC,QAAU,CAAC,UAChC,MACJ,IAAK,QACDpC,EAAY,CAAElM,KAAM,QAAS0M,WAAY,SACzC2B,EAAYD,EAAIE,EAAI,CAAC,QAAU,CAAC,UAChC,MACJ,IAAK,QACDpC,EAAY,CAAElM,KAAM,QAAS0M,WAAY,SACzC2B,EAAYD,EAAIE,EAAI,CAAC,QAAU,CAAC,UAChC,MACJ,IAAK,UACL,IAAK,iBACL,IAAK,iBACL,IAAK,iBACDpC,EAAY,CAAElM,KAAM,OAAQ0M,WAAY0B,EAAIG,KAC5CF,EAAYD,EAAIE,EAAI,CAAC,cAAgB,GACrC,MACJ,QACI,MAAM,IAAI/C,EAAiB,gEAEnC,MAEJ,IAAK,MACD,OAAQ6C,EAAI/I,KACR,IAAK,UACD6G,EAAY,CAAElM,KAAM,WACpBqO,EAAYD,EAAIE,EAAI,CAAC,QAAU,CAAC,UAChC,MACJ,IAAK,QACDpC,EAAY,CAAElM,KAAMoO,EAAIG,KACxBF,EAAYD,EAAIE,EAAI,CAAC,QAAU,CAAC,UAChC,MACJ,IAAK,UACL,IAAK,iBACL,IAAK,iBACL,IAAK,iBACDpC,EAAY,CAAElM,KAAMoO,EAAIG,KACxBF,EAAYD,EAAIE,EAAI,CAAC,cAAgB,GACrC,MACJ,QACI,MAAM,IAAI/C,EAAiB,gEAEnC,MAEJ,QACI,MAAM,IAAIA,EAAiB,+DAEnC,MAAO,CAAEW,YAAWmC,YACxB,CAKqCG,CAAcJ,GACzCK,EAAO,CACTvC,EACAkC,EAAIM,MAAO,EACXN,EAAIO,SAAWN,GAEbO,EAAU,IAAKR,GAGrB,cAFOQ,EAAQvJ,WACRuJ,EAAQC,IACRpF,EAAOqF,OAAOC,UAAU,MAAOH,KAAYH,IClGhDO,EAAkBC,GAAM5E,EAAO4E,GACrC,IACIC,EACJ,MAAMC,EAAenF,GACoB,cAA9BA,IAAMwD,OAAOC,aAElB2B,EAAiBjB,MAAOkB,EAAOrF,EAAKoE,EAAK/I,EAAKiK,GAAS,KACzD,IAAIC,EAASF,EAAMtL,IAAIiG,GACvB,GAAIuF,IAASlK,GACT,OAAOkK,EAAOlK,GAElB,MAAMmK,QAAkBC,EAAU,IAAKrB,EAAK/I,QAS5C,OARIiK,GACAhG,OAAOgG,OAAOtF,GACbuF,EAIDA,EAAOlK,GAAOmK,EAHdH,EAAMK,IAAI1F,EAAK,CAAE3E,CAACA,GAAMmK,IAKrBA,GA4CX,IAAAG,EA1C2B,CAAC3F,EAAK3E,KAC7B,GAAI8J,EAAYnF,GAAM,CAClB,IAAIoE,EAAMpE,EAAI4F,OAAO,CAAEC,OAAQ,QAO/B,cANOzB,EAAIE,SACJF,EAAI0B,UACJ1B,EAAI2B,UACJ3B,EAAI4B,SACJ5B,EAAI6B,SACJ7B,EAAI8B,GACP9B,EAAIa,EACGD,EAAeZ,EAAIa,IAE9BC,IAAaA,EAAW,IAAIiB,SACrBf,EAAeF,EAAUlF,EAAKoE,EAAK/I,GAClD,CACI,GAAI2I,EAAMhE,GAAM,CACZ,GAAIA,EAAIiF,EACJ,OAAO5E,EAAOL,EAAIiF,GACtBC,IAAaA,EAAW,IAAIiB,SAE5B,OADkBf,EAAeF,EAAUlF,EAAKA,EAAK3E,GAAK,EAElE,CACI,OAAO2E,GCxBJmE,eAAesB,EAAUrB,EAAK/I,GACjC,IAAKqI,EAASU,GACV,MAAM,IAAIvD,UAAU,yBAGxB,OADAxF,IAAQA,EAAM+I,EAAI/I,KACV+I,EAAIH,KACR,IAAK,MACD,GAAqB,iBAAVG,EAAIa,IAAmBb,EAAIa,EAClC,MAAM,IAAIpE,UAAU,2CAExB,OAAOuF,EAAgBhC,EAAIa,GAC/B,IAAK,MACD,GAAI,QAASb,QAAmBlP,IAAZkP,EAAIiC,IACpB,MAAM,IAAI9E,EAAiB,sEAEnC,IAAK,KACL,IAAK,MACD,OAAO+E,EAAY,IAAKlC,EAAK/I,QACjC,QACI,MAAM,IAAIkG,EAAiB,gDAEvC,CCzCA,MAAMgF,EAAOvG,GAAQA,IAAMwD,OAAOC,aAC5B+C,EAAe,CAACnL,EAAK2E,EAAKyG,KAC5B,QAAgBvR,IAAZ8K,EAAI6E,KAAiC,QAAZ7E,EAAI6E,IAC7B,MAAM,IAAIhE,UAAU,oEAExB,QAAoB3L,IAAhB8K,EAAI2E,UAA2D,IAAlC3E,EAAI2E,QAAQ/B,WAAW6D,GACpD,MAAM,IAAI5F,UAAU,yEAAyE4F,KAEjG,QAAgBvR,IAAZ8K,EAAI3E,KAAqB2E,EAAI3E,MAAQA,EACrC,MAAM,IAAIwF,UAAU,gEAAgExF,KAExF,OAAO,GAELqL,EAAqB,CAACrL,EAAK2E,EAAKyG,EAAOE,KACzC,KAAI3G,aAAe/D,YAAnB,CAEA,GAAI0K,GAAYC,EAAU5G,GAAM,CAC5B,GJVD,SAAqBA,GACxB,OAAOgE,EAAMhE,IAAoB,QAAZA,EAAIiE,KAAkC,iBAAVjE,EAAIiF,CACzD,CIQY4B,CAAgB7G,IAAQwG,EAAanL,EAAK2E,EAAKyG,GAC/C,OACJ,MAAM,IAAI5F,UAAU,0HAC5B,CACI,IAAK0C,EAAUvD,GACX,MAAM,IAAIa,UAAUwC,EAAgBhI,EAAK2E,KAAQkD,EAAO,aAAcyD,EAAW,eAAiB,OAEtG,GAAiB,WAAb3G,EAAI/K,KACJ,MAAM,IAAI4L,UAAU,GAAG0F,EAAIvG,iEAV3B,GA6CR,SAAS8G,EAAaH,EAAUtL,EAAK2E,EAAKyG,GACpBpL,EAAI0L,WAAW,OACrB,QAAR1L,GACAA,EAAI0L,WAAW,UACf,qBAAqBhL,KAAKV,GAE1BqL,EAAmBrL,EAAK2E,EAAKyG,EAAOE,GAtChB,EAACtL,EAAK2E,EAAKyG,EAAOE,KAC1C,GAAIA,GAAYC,EAAU5G,GACtB,OAAQyG,GACJ,IAAK,OACD,GJ/BT,SAAsBzG,GACzB,MAAmB,QAAZA,EAAIiE,KAAkC,iBAAVjE,EAAIsE,CAC3C,CI6BoB0C,CAAiBhH,IAAQwG,EAAanL,EAAK2E,EAAKyG,GAChD,OACJ,MAAM,IAAI5F,UAAU,oDACxB,IAAK,SACD,GJhCT,SAAqBb,GACxB,MAAmB,QAAZA,EAAIiE,UAAkC,IAAVjE,EAAIsE,CAC3C,CI8BoB2C,CAAgBjH,IAAQwG,EAAanL,EAAK2E,EAAKyG,GAC/C,OACJ,MAAM,IAAI5F,UAAU,mDAGhC,IAAK0C,EAAUvD,GACX,MAAM,IAAIa,UAAUwC,EAAgBhI,EAAK2E,KAAQkD,EAAOyD,EAAW,eAAiB,OAExF,GAAiB,WAAb3G,EAAI/K,KACJ,MAAM,IAAI4L,UAAU,GAAG0F,EAAIvG,uEAE/B,GAAc,SAAVyG,GAAiC,WAAbzG,EAAI/K,KACxB,MAAM,IAAI4L,UAAU,GAAG0F,EAAIvG,2EAE/B,GAAc,YAAVyG,GAAoC,WAAbzG,EAAI/K,KAC3B,MAAM,IAAI4L,UAAU,GAAG0F,EAAIvG,8EAE/B,GAAIA,EAAIkC,WAAuB,WAAVuE,GAAmC,YAAbzG,EAAI/K,KAC3C,MAAM,IAAI4L,UAAU,GAAG0F,EAAIvG,4EAE/B,GAAIA,EAAIkC,WAAuB,YAAVuE,GAAoC,YAAbzG,EAAI/K,KAC5C,MAAM,IAAI4L,UAAU,GAAG0F,EAAIvG,8EAY3BkH,CAAoB7L,EAAK2E,EAAKyG,EAAOE,EAE7C,CACeG,EAAaK,UAAKjS,GAAW,GACrC,MAAMkS,EAAsBN,EAAaK,UAAKjS,GAAW,GCxEhE,MAAMmS,EAASlD,MAAO9I,EAAK2E,EAAKjJ,EAAW2H,KACvC,MAAM8G,QCAKrB,eAA4B9I,EAAK2E,EAAKyG,GAOjD,GAFIzG,QAAY2F,EAA6B3F,EAAK3E,GAE9C0E,EAAYC,GAEZ,OADAsC,EAAkBtC,EAAK3E,EAAKoL,GACrBzG,EAEX,GAAIA,aAAe/D,WAAY,CAC3B,IAAKZ,EAAI0L,WAAW,MAChB,MAAM,IAAIlG,UAAUwC,EAAgBrD,KAAQkD,IAEhD,OAAOzD,EAAOqF,OAAOC,UAAU,MAAO/E,EAAK,CAAEoC,KAAM,OAAO/G,EAAIgH,OAAM,KAAOrM,KAAM,SAAU,EAAO,CAACyQ,GAC3G,CACI,MAAM,IAAI5F,UAAUwC,EAAgBrD,KAAQkD,EAAO,aAAc,gBACrE,CDlB4BoE,CAAajM,EAAK2E,EAAK,UELpC,EAAC3E,EAAK2E,KACjB,GAAI3E,EAAI0L,WAAW,OAAS1L,EAAI0L,WAAW,MAAO,CAC9C,MAAMQ,cAAEA,GAAkBvH,EAAIkC,UAC9B,GAA6B,iBAAlBqF,GAA8BA,EAAgB,KACrD,MAAM,IAAI1G,UAAU,GAAGxF,yDAEnC,GFAImM,CAAenM,EAAKmK,GACpB,MAAMtD,EGNK,SAAmB7G,EAAK6G,GACnC,MAAME,EAAO,OAAO/G,EAAIgH,OAAM,KAC9B,OAAQhH,GACJ,IAAK,QACL,IAAK,QACL,IAAK,QACD,MAAO,CAAE+G,OAAMpM,KAAM,QACzB,IAAK,QACL,IAAK,QACL,IAAK,QACD,MAAO,CAAEoM,OAAMpM,KAAM,UAAWyR,WAAYpM,EAAIgH,WAAa,GACjE,IAAK,QACL,IAAK,QACL,IAAK,QACD,MAAO,CAAED,OAAMpM,KAAM,qBACzB,IAAK,QACL,IAAK,QACL,IAAK,QACD,MAAO,CAAEoM,OAAMpM,KAAM,QAAS0M,WAAYR,EAAUQ,YACxD,IAAK,UACD,MAAO,CAAE1M,KAAM,WACnB,IAAK,QACD,MAAO,CAAEA,KAAMkM,EAAUlM,MAC7B,QACI,MAAM,IAAIuL,EAAiB,OAAOlG,gEAE9C,CHpBsBqM,CAAgBrM,EAAKmK,EAAUtD,WACjD,IACI,aAAazC,EAAOqF,OAAOuC,OAAOnF,EAAWsD,EAAWzO,EAAW2H,EAC3E,CACI,MACI,OAAO,CACf,GIFOyF,eAAewD,EAAgBC,EAAK5H,EAAKhG,GAC5C,IAAK0J,EAASkE,GACV,MAAM,IAAIpG,EAAW,mCAEzB,QAAsBtM,IAAlB0S,EAAIC,gBAA0C3S,IAAf0S,EAAIE,OACnC,MAAM,IAAItG,EAAW,yEAEzB,QAAsBtM,IAAlB0S,EAAIC,WAAoD,iBAAlBD,EAAIC,UAC1C,MAAM,IAAIrG,EAAW,uCAEzB,QAAoBtM,IAAhB0S,EAAI3G,QACJ,MAAM,IAAIO,EAAW,uBAEzB,GAA6B,iBAAlBoG,EAAI7Q,UACX,MAAM,IAAIyK,EAAW,2CAEzB,QAAmBtM,IAAf0S,EAAIE,SAAyBpE,EAASkE,EAAIE,QAC1C,MAAM,IAAItG,EAAW,yCAEzB,IAAIuG,EAAa,CAAA,EACjB,GAAIH,EAAIC,UACJ,IACI,MAAMG,EAAkBC,EAAUL,EAAIC,WACtCE,EAAaG,KAAKhE,MAAM/D,EAAQE,OAAO2H,GACnD,CACQ,MACI,MAAM,IAAIxG,EAAW,kCACjC,CAEI,ICxCe,KAAI2G,KACnB,MAAMC,EAAUD,EAAQhF,OAAOC,SAC/B,GAAuB,IAAnBgF,EAAQlM,QAAmC,IAAnBkM,EAAQlM,OAChC,OAAO,EAEX,IAAImM,EACJ,IAAK,MAAMP,KAAUM,EAAS,CAC1B,MAAME,EAAahJ,OAAOiJ,KAAKT,GAC/B,GAAKO,GAAoB,IAAbA,EAAIG,KAIhB,IAAK,MAAMC,KAAaH,EAAY,CAChC,GAAID,EAAIK,IAAID,GACR,OAAO,EAEXJ,EAAIM,IAAIF,EACpB,MARYJ,EAAM,IAAIO,IAAIN,EAS1B,CACI,OAAO,GDqBFO,CAAWd,EAAYH,EAAIE,QAC5B,MAAM,IAAItG,EAAW,6EAEzB,MAAMsH,EAAa,IACZf,KACAH,EAAIE,QAELiB,EE9CV,SAAsBC,EAAKC,EAAmBC,EAAkBlB,EAAiBc,GAC7E,QAAwB5T,IAApB4T,EAAWK,WAAgDjU,IAA1B8S,GAAiBmB,KAClD,MAAM,IAAIH,EAAI,kEAElB,IAAKhB,QAA4C9S,IAAzB8S,EAAgBmB,KACpC,OAAO,IAAIP,IAEf,IAAKpM,MAAM4M,QAAQpB,EAAgBmB,OACC,IAAhCnB,EAAgBmB,KAAKjN,QACrB8L,EAAgBmB,KAAKxG,KAAMrC,GAA2B,iBAAVA,GAAuC,IAAjBA,EAAMpE,QACxE,MAAM,IAAI8M,EAAI,yFAElB,IAAIK,EAEAA,OADqBnU,IAArBgU,EACa,IAAII,IAAI,IAAIhK,OAAOiK,QAAQL,MAAsBD,EAAkBM,YAGnEN,EAEjB,IAAK,MAAMR,KAAaT,EAAgBmB,KAAM,CAC1C,IAAKE,EAAWX,IAAID,GAChB,MAAM,IAAIlH,EAAiB,+BAA+BkH,wBAE9D,QAA8BvT,IAA1B4T,EAAWL,GACX,MAAM,IAAIO,EAAI,+BAA+BP,iBAEjD,GAAIY,EAAWtP,IAAI0O,SAA6CvT,IAA/B8S,EAAgBS,GAC7C,MAAM,IAAIO,EAAI,+BAA+BP,iCAEzD,CACI,OAAO,IAAIG,IAAIZ,EAAgBmB,KACnC,CFeuBK,CAAahI,EAAY,IAAI8H,IAAI,CAAC,CAAC,OAAO,KAAStP,GAASmP,KAAMpB,EAAYe,GACjG,IAAIW,GAAM,EACV,GAAIV,EAAWL,IAAI,SACfe,EAAM1B,EAAW0B,IACE,kBAARA,GACP,MAAM,IAAIjI,EAAW,2EAG7B,MAAMnG,IAAEA,GAAQyN,EAChB,GAAmB,iBAARzN,IAAqBA,EAC5B,MAAM,IAAImG,EAAW,6DAEzB,MAAMkI,EAAa1P,GG3DI,EAAC2P,EAAQD,KAChC,QAAmBxU,IAAfwU,KACElN,MAAM4M,QAAQM,IAAeA,EAAW/G,KAAMiH,GAAmB,iBAANA,IAC7D,MAAM,IAAI/I,UAAU,IAAI8I,yCAE5B,GAAKD,EAGL,OAAO,IAAId,IAAIc,IHmDeG,CAAmB,aAAc7P,EAAQ0P,YACvE,GAAIA,IAAeA,EAAWhB,IAAIrN,GAC9B,MAAM,IAAIgG,EAAkB,wDAEhC,GAAIoI,GACA,GAA2B,iBAAhB7B,EAAI3G,QACX,MAAM,IAAIO,EAAW,qCAGxB,GAA2B,iBAAhBoG,EAAI3G,WAA0B2G,EAAI3G,mBAAmBhF,YACjE,MAAM,IAAIuF,EAAW,0DAEzB,IAAIsI,GAAc,EACC,mBAAR9J,GACPA,QAAYA,EAAI+H,EAAYH,GAC5BkC,GAAc,EACd1C,EAAoB/L,EAAK2E,EAAK,UAC1BgE,EAAMhE,KACNA,QAAYyF,EAAUzF,EAAK3E,KAI/B+L,EAAoB/L,EAAK2E,EAAK,UAElC,MAAMtB,EhB/EH,YAAmBqL,GACtB,MAAMvB,EAAOuB,EAAQC,OAAO,CAAC3B,GAAOnM,YAAamM,EAAMnM,EAAQ,GACzD+N,EAAM,IAAIhO,WAAWuM,GAC3B,IAAIrM,EAAI,EACR,IAAK,MAAME,KAAU0N,EACjBE,EAAIvE,IAAIrJ,EAAQF,GAChBA,GAAKE,EAAOH,OAEhB,OAAO+N,CACX,CgBsEiBC,CAAOhK,EAAQ3D,OAAOqL,EAAIC,WAAa,IAAK3H,EAAQ3D,OAAO,KAA6B,iBAAhBqL,EAAI3G,QAAuBf,EAAQ3D,OAAOqL,EAAI3G,SAAW2G,EAAI3G,SAClJ,IAAIlK,EACJ,IACIA,EAAYkR,EAAUL,EAAI7Q,UAClC,CACI,MACI,MAAM,IAAIyK,EAAW,2CAC7B,CAEI,UADuB6F,EAAOhM,EAAK2E,EAAKjJ,EAAW2H,GAE/C,MAAM,IAAIoD,EAEd,IAAIb,EACJ,GAAIwI,EACA,IACIxI,EAAUgH,EAAUL,EAAI3G,QACpC,CACQ,MACI,MAAM,IAAIO,EAAW,yCACjC,MAGQP,EAD4B,iBAAhB2G,EAAI3G,QACNf,EAAQ3D,OAAOqL,EAAI3G,SAGnB2G,EAAI3G,QAElB,MAAMkJ,EAAS,CAAElJ,WAOjB,YANsB/L,IAAlB0S,EAAIC,YACJsC,EAAOnC,gBAAkBD,QAEV7S,IAAf0S,EAAIE,SACJqC,EAAOC,kBAAoBxC,EAAIE,QAE/BgC,EACO,IAAKK,EAAQnK,OAEjBmK,CACX,CIzHA,MAEME,EAAMC,MAGNC,EAAQ,oIACd,IAAAC,EAAgB1O,IACZ,MAAM2O,EAAUF,EAAMG,KAAK5O,GAC3B,IAAK2O,GAAYA,EAAQ,IAAMA,EAAQ,GACnC,MAAM,IAAI5J,UAAU,8BAExB,MAAM8C,EAAQgH,WAAWF,EAAQ,IAEjC,IAAIG,EACJ,OAFaH,EAAQ,GAAGI,eAGpB,IAAK,MACL,IAAK,OACL,IAAK,SACL,IAAK,UACL,IAAK,IACDD,EAAcpS,KAAKsS,MAAMnH,GACzB,MACJ,IAAK,SACL,IAAK,UACL,IAAK,MACL,IAAK,OACL,IAAK,IACDiH,EAAcpS,KAAKsS,MA3BhB,GA2BsBnH,GACzB,MACJ,IAAK,OACL,IAAK,QACL,IAAK,KACL,IAAK,MACL,IAAK,IACDiH,EAAcpS,KAAKsS,MAjClBC,KAiCwBpH,GACzB,MACJ,IAAK,MACL,IAAK,OACL,IAAK,IACDiH,EAAcpS,KAAKsS,MAAMnH,EAAQ0G,GACjC,MACJ,IAAK,OACL,IAAK,QACL,IAAK,IACDO,EAAcpS,KAAKsS,MAzClBT,OAyCwB1G,GACzB,MACJ,QACIiH,EAAcpS,KAAKsS,MA3ClBT,SA2CwB1G,GAGjC,MAAmB,MAAf8G,EAAQ,IAA6B,QAAfA,EAAQ,IACtBG,EAELA,GChDX,MAAMI,EAAgBrH,GAAUA,EAAMkH,cAAcrK,QAAQ,iBAAkB,IAU9E,IAAAyK,GAAe,CAACjD,EAAiBkD,EAAgBlR,EAAU,MACvD,IAAIiH,EACJ,IACIA,EAAUiH,KAAKhE,MAAM/D,EAAQE,OAAO6K,GAC5C,CACI,MACJ,CACI,IAAKxH,EAASzC,GACV,MAAM,IAAIQ,EAAW,kDAEzB,MAAM0J,IAAEA,GAAQnR,EAChB,GAAImR,IACgC,iBAAxBnD,EAAgBmD,KACpBH,EAAahD,EAAgBmD,OAASH,EAAaG,IACvD,MAAM,IAAInK,EAAyB,oCAAqCC,EAAS,MAAO,gBAE5F,MAAMmK,eAAEA,EAAiB,GAAEC,OAAEA,EAAMC,QAAEA,EAAOC,SAAEA,EAAQC,YAAEA,GAAgBxR,EAClEyR,EAAgB,IAAIL,QACNlW,IAAhBsW,GACAC,EAAcpO,KAAK,YACNnI,IAAbqW,GACAE,EAAcpO,KAAK,YACPnI,IAAZoW,GACAG,EAAcpO,KAAK,YACRnI,IAAXmW,GACAI,EAAcpO,KAAK,OACvB,IAAK,MAAM6D,KAAS,IAAI0H,IAAI6C,EAAcC,WACtC,KAAMxK,KAASD,GACX,MAAM,IAAID,EAAyB,qBAAqBE,WAAgBD,EAASC,EAAO,WAGhG,GAAImK,KACE7O,MAAM4M,QAAQiC,GAAUA,EAAS,CAACA,IAASzI,SAAS3B,EAAQ0K,KAC9D,MAAM,IAAI3K,EAAyB,+BAAgCC,EAAS,MAAO,gBAEvF,GAAIqK,GAAWrK,EAAQ2K,MAAQN,EAC3B,MAAM,IAAItK,EAAyB,+BAAgCC,EAAS,MAAO,gBAEvF,GAAIsK,IA/CuBM,EAgDA5K,EAAQ6K,IAhDIC,EAgDqB,iBAAbR,EAAwB,CAACA,GAAYA,IA/C1D,iBAAfM,EACAE,EAAUnJ,SAASiJ,GAE1BrP,MAAM4M,QAAQyC,IACPE,EAAUpJ,KAAKiG,IAAIhF,UAAU8E,IAAIvB,KAAK,IAAIyB,IAAIiD,OA4CrD,MAAM,IAAI7K,EAAyB,+BAAgCC,EAAS,MAAO,gBAjD7D,IAAC4K,EAAYE,EAmDvC,IAAIC,EACJ,cAAehS,EAAQiS,gBACnB,IAAK,SACDD,EAAYxB,EAAKxQ,EAAQiS,gBACzB,MACJ,IAAK,SACDD,EAAYhS,EAAQiS,eACpB,MACJ,IAAK,YACDD,EAAY,EACZ,MACJ,QACI,MAAM,IAAInL,UAAU,sCAE5B,MAAMqL,YAAEA,GAAgBlS,EAClBzB,GCxEM4T,EDwEMD,GAAe,IAAI5T,KCxEhBE,KAAK4T,MAAMD,EAAKE,UAAY,MAAtC,IAACF,EDyEZ,SAAqBjX,IAAhB+L,EAAQqL,KAAqBd,IAAuC,iBAAhBvK,EAAQqL,IAC7D,MAAM,IAAItL,EAAyB,+BAAgCC,EAAS,MAAO,WAEvF,QAAoB/L,IAAhB+L,EAAQsL,IAAmB,CAC3B,GAA2B,iBAAhBtL,EAAQsL,IACf,MAAM,IAAIvL,EAAyB,+BAAgCC,EAAS,MAAO,WAEvF,GAAIA,EAAQsL,IAAMhU,EAAMyT,EACpB,MAAM,IAAIhL,EAAyB,qCAAsCC,EAAS,MAAO,eAErG,CACI,QAAoB/L,IAAhB+L,EAAQuL,IAAmB,CAC3B,GAA2B,iBAAhBvL,EAAQuL,IACf,MAAM,IAAIxL,EAAyB,+BAAgCC,EAAS,MAAO,WAEvF,GAAIA,EAAQuL,KAAOjU,EAAMyT,EACrB,MAAM,IAAI5K,EAAW,qCAAsCH,EAAS,MAAO,eAEvF,CACI,GAAIuK,EAAa,CACb,MAAMiB,EAAMlU,EAAM0I,EAAQqL,IAE1B,GAAIG,EAAMT,GADyB,iBAAhBR,EAA2BA,EAAchB,EAAKgB,IAE7D,MAAM,IAAIpK,EAAW,2DAA4DH,EAAS,MAAO,gBAErG,GAAIwL,EAAM,EAAIT,EACV,MAAM,IAAIhL,EAAyB,gEAAiEC,EAAS,MAAO,eAEhI,CACI,OAAOA,GEnGJkD,eAAeuI,GAAUC,EAAK3M,EAAKhG,GACtC,MAAM4S,QCDHzI,eAA6ByD,EAAK5H,EAAKhG,GAI1C,GAHI4N,aAAe3L,aACf2L,EAAMzH,EAAQE,OAAOuH,IAEN,iBAARA,EACP,MAAM,IAAIpG,EAAW,8CAEzB,MAAQ,EAAGwG,EAAiB,EAAG/G,EAAS,EAAGlK,EAASmF,OAAEA,GAAW0L,EAAIiF,MAAM,KAC3E,GAAe,IAAX3Q,EACA,MAAM,IAAIsF,EAAW,uBAEzB,MAAMoL,QAAiBjF,EAAgB,CAAE1G,UAAS4G,UAAWG,EAAiBjR,aAAaiJ,EAAKhG,GAC1FmQ,EAAS,CAAElJ,QAAS2L,EAAS3L,QAAS+G,gBAAiB4E,EAAS5E,iBACtE,MAAmB,mBAARhI,EACA,IAAKmK,EAAQnK,IAAK4M,EAAS5M,KAE/BmK,CACX,CDhB2B2C,CAAcH,EAAK3M,EAAKhG,GAC/C,GAAI4S,EAAS5E,gBAAgBmB,MAAMvG,SAAS,SAA2C,IAAjCgK,EAAS5E,gBAAgByB,IAC3E,MAAM,IAAIhI,EAAW,uCAEzB,MACM0I,EAAS,CAAElJ,QADDgK,GAAW2B,EAAS5E,gBAAiB4E,EAAS3L,QAASjH,GAC7CgO,gBAAiB4E,EAAS5E,iBACpD,MAAmB,mBAARhI,EACA,IAAKmK,EAAQnK,IAAK4M,EAAS5M,KAE/BmK,CACX,CEQA,SAAS4C,GAAU/M,GACf,OAAO0D,EAAS1D,EACpB,CACA,SAASgN,GAAMC,GACX,MAA+B,mBAApBC,gBACAA,gBAAgBD,GAEpB/E,KAAKhE,MAAMgE,KAAKiF,UAAUF,GACrC,CACA,MAAMG,GACF,WAAAjZ,CAAYkZ,GAER,GADA/Y,KAAKgZ,QAAU,IAAInH,SAjB3B,SAAoBkH,GAChB,OAAQA,GACY,iBAATA,GACP7Q,MAAM4M,QAAQiE,EAAK9E,OACnB8E,EAAK9E,KAAKgF,MAAMR,GACxB,CAaaS,CAAWH,GACZ,MAAM,IAAI3L,EAAY,8BAE1BpN,KAAKmZ,MAAQT,GAAMK,EAC3B,CACI,YAAMK,CAAO1F,EAAiB2F,GAC1B,MAAMtS,IAAEA,EAAGuS,IAAEA,GAAQ,IAAK5F,KAAoB2F,GAAO7F,QAC/C7D,EAtCd,SAAuB5I,GACnB,OAAuB,iBAARA,GAAoBA,EAAIgH,MAAM,EAAG,IAC5C,IAAK,KACL,IAAK,KACD,MAAO,MACX,IAAK,KACD,MAAO,KACX,IAAK,KACD,MAAO,MACX,QACI,MAAM,IAAId,EAAiB,kDAEvC,CA0BoBsM,CAAcxS,GACpByS,EAAaxZ,KAAKmZ,MAAMlF,KAAKpF,OAAQiB,IACvC,IAAI2J,EAAY9J,IAAQG,EAAIH,IAa5B,GAZI8J,GAA4B,iBAARH,IACpBG,EAAYH,IAAQxJ,EAAIwJ,KAExBG,GAAgC,iBAAZ3J,EAAI/I,MACxB0S,EAAY1S,IAAQ+I,EAAI/I,KAExB0S,GAAgC,iBAAZ3J,EAAIS,MACxBkJ,EAAwB,QAAZ3J,EAAIS,KAEhBkJ,GAAavR,MAAM4M,QAAQhF,EAAIO,WAC/BoJ,EAAY3J,EAAIO,QAAQ/B,SAAS,WAEjCmL,EACA,OAAQ1S,GACJ,IAAK,QACD0S,EAAwB,UAAZ3J,EAAIG,IAChB,MACJ,IAAK,SACDwJ,EAAwB,cAAZ3J,EAAIG,IAChB,MACJ,IAAK,QACDwJ,EAAwB,UAAZ3J,EAAIG,IAChB,MACJ,IAAK,QACDwJ,EAAwB,UAAZ3J,EAAIG,IAChB,MACJ,IAAK,UACDwJ,EAAwB,YAAZ3J,EAAIG,IAChB,MACJ,IAAK,QACDwJ,EAAwB,YAAZ3J,EAAIG,KAAiC,UAAZH,EAAIG,IAIrD,OAAOwJ,KAEH,EAAG3J,EAAGlI,OAAEA,GAAW4R,EAC3B,GAAe,IAAX5R,EACA,MAAM,IAAIyF,EAEd,GAAe,IAAXzF,EAAc,CACd,MAAM9G,EAAQ,IAAIwM,GACZ0L,QAAEA,GAAYhZ,KASpB,MARAc,EAAMoO,OAAOwK,eAAiB7J,kBAC1B,IAAK,MAAMC,KAAO0J,EACd,gBACgBG,GAAmBX,EAASlJ,EAAK/I,EACrE,CACoB,MAAM,CAE1B,EACkBjG,CAClB,CACQ,OAAO6Y,GAAmB3Z,KAAKgZ,QAASlJ,EAAK/I,EACrD,EAEA8I,eAAe8J,GAAmB5I,EAAOjB,EAAK/I,GAC1C,MAAMkK,EAASF,EAAMtL,IAAIqK,IAAQiB,EAAMK,IAAItB,EAAK,CAAA,GAAIrK,IAAIqK,GACxD,QAAoBlP,IAAhBqQ,EAAOlK,GAAoB,CAC3B,MAAM2E,QAAYyF,EAAU,IAAKrB,EAAKM,KAAK,GAAQrJ,GACnD,GAAI2E,aAAe/D,YAA2B,WAAb+D,EAAI/K,KACjC,MAAM,IAAIyM,EAAY,gDAE1B6D,EAAOlK,GAAO2E,CACtB,CACI,OAAOuF,EAAOlK,EAClB,CACO,SAAS6S,GAAkBb,GAC9B,MAAM3H,EAAM,IAAI0H,GAAYC,GACtBc,EAAchK,MAAO6D,EAAiB2F,IAAUjI,EAAIgI,OAAO1F,EAAiB2F,GASlF,OARArO,OAAO8O,iBAAiBD,EAAa,CACjCd,KAAM,CACF1J,MAAO,IAAMqJ,GAAMtH,EAAI+H,OACvBY,YAAY,EACZC,cAAc,EACdC,UAAU,KAGXJ,CACX,CClHA,IAAIK,GACJ,GAAyB,oBAAd5U,YAA8BA,UAAU6U,WAAW1H,aAAa,gBAAiB,CAGxFyH,GAAa,GAFA,UACG,WAEpB,CACO,MAAME,GAAYlL,SAgBzB,MAAMmL,GACF,WAAAxa,CAAYya,EAAK5U,GACb,KAAM4U,aAAe/R,KACjB,MAAM,IAAIgE,UAAU,kCAlBhC,IAA0BP,EAAOuO,EAoBzBva,KAAKwa,KAAO,IAAIjS,IAAI+R,EAAIG,MACxBza,KAAK0a,SAAW,CAAEC,MAAOjV,GAASiV,MAAO9G,QAASnO,GAASmO,SAC3D7T,KAAK4a,iBACmC,iBAA7BlV,GAASmV,gBAA+BnV,GAASmV,gBAAkB,IAC9E7a,KAAK8a,kBACoC,iBAA9BpV,GAASqV,iBAAgCrV,GAASqV,iBAAmB,IAChF/a,KAAKgb,aAA+C,iBAAzBtV,GAAS6U,YAA2B7U,GAAS6U,YAAc,SACzD3Z,IAAzB8E,IAAU0U,MACVpa,KAAKib,OAASvV,IAAU0U,IA5BVpO,EA6BOtG,IAAU0U,IA7BVG,EA6BsBva,KAAKgb,aA5BnC,iBAAVhP,GAAgC,OAAVA,GAG3B,QAASA,GAA+B,iBAAdA,EAAMkP,OAAoBlX,KAAKC,MAAQ+H,EAAMkP,KAAOX,IAG9E,SAAUvO,GACXoD,EAASpD,EAAM+M,OACf7Q,MAAM4M,QAAQ9I,EAAM+M,KAAK9E,OACzB/L,MAAMoH,UAAU2J,MAAM1J,KAAKvD,EAAM+M,KAAK9E,KAAM7E,KAoBrCpP,KAAKmb,eAAiBnb,KAAKib,OAAOC,IAClClb,KAAKob,OAASxB,GAAkB5Z,KAAKib,OAAOlC,OAG5D,CACI,WAAAsC,GACI,MAAsC,iBAAxBrb,KAAKmb,gBACbnX,KAAKC,MAAQjE,KAAKmb,eAAiBnb,KAAK8a,iBAEtD,CACI,KAAAQ,GACI,MAAsC,iBAAxBtb,KAAKmb,gBACbnX,KAAKC,MAAQjE,KAAKmb,eAAiBnb,KAAKgb,YAEtD,CACI,YAAM5B,CAAO1F,EAAiB2F,GACrBrZ,KAAKob,QAAWpb,KAAKsb,eAChBtb,KAAKub,SAEf,IACI,aAAavb,KAAKob,OAAO1H,EAAiB2F,EACtD,CACQ,MAAOmC,GACH,GAAIA,aAAenO,IACY,IAAvBrN,KAAKqb,cAEL,aADMrb,KAAKub,SACJvb,KAAKob,OAAO1H,EAAiB2F,GAG5C,MAAMmC,CAClB,CACA,CACI,YAAMD,GACEvb,KAAKyb,gBA1EoB,oBAAlBC,eACW,oBAAdpW,WAAqD,uBAAxBA,UAAU6U,WACvB,oBAAhBwB,aAA+C,WAAhBA,eAyEnC3b,KAAKyb,mBAAgB7a,GAEzB,MAAMiT,EAAU,IAAI+H,QAAQ5b,KAAK0a,SAAS7G,SACtCqG,KAAerG,EAAQO,IAAI,gBAC3BP,EAAQzC,IAAI,aAAc8I,IAC1Bla,KAAK0a,SAAS7G,QAAU7I,OAAO6Q,YAAYhI,EAAQoB,YAEvDjV,KAAKyb,gBAAkBzb,KAAKyb,cCtFlB5L,OAAOyK,EAAKpY,EAASwD,KACnC,IAAIoW,EACAvX,EACAwX,GAAW,EACgB,mBAApBC,kBACPF,EAAa,IAAIE,gBACjBzX,EAAKzB,WAAW,KACZiZ,GAAW,EACXD,EAAWG,SACZ/Z,IAEP,MAAMf,QAAiB+a,MAAM5B,EAAIG,KAAM,CACnC0B,OAAQL,EAAaA,EAAWK,YAASvb,EACzCwb,SAAU,SACVvI,QAASnO,EAAQmO,UAClB/P,MAAO0X,IACN,GAAIO,EACA,MAAM,IAAIxO,EACd,MAAMiO,IAIV,QAFW5a,IAAP2D,GACApB,aAAaoB,GACO,MAApBpD,EAASV,OACT,MAAM,IAAI+L,EAAU,2DAExB,IACI,aAAarL,EAASkb,MAC9B,CACI,MACI,MAAM,IAAI7P,EAAU,6DAC5B,GDwDoD8P,CAAUtc,KAAKwa,KAAMxa,KAAK4a,iBAAkB5a,KAAK0a,UACxF7W,KAAMwY,IACPrc,KAAKob,OAASxB,GAAkByC,GAC5Brc,KAAKib,SACLjb,KAAKib,OAAOC,IAAMlX,KAAKC,MACvBjE,KAAKib,OAAOlC,KAAOsD,GAEvBrc,KAAKmb,eAAiBnX,KAAKC,MAC3BjE,KAAKyb,mBAAgB7a,IAEpBkD,MAAO0X,IAER,MADAxb,KAAKyb,mBAAgB7a,EACf4a,WAEJxb,KAAKyb,aACnB,EEpGO,MAAM1P,GAASwQ,eCapB,WAAA1c,CAAY2c,EAAiC9W,EAAyB,IAEpE,GAJM1F,KAAAyc,WAAY,EAIO,iBAAdD,EAAwB,CACjC,MAAME,EAAUC,SAASC,cAAcJ,GACvC,IAAKE,EACH,MAAM,IAAIxb,MAAM,gCAAgCsb,KAElDxc,KAAKwc,UAAYE,OAEjB1c,KAAKwc,UAAYA,EAInBxc,KAAK0F,QAAU,CACb3D,UAAW2D,EAAQ3D,WAAa,GAChCE,iBAAkByD,EAAQzD,kBAAoB,YAC9CC,QAASwD,EAAQxD,SAAW,IAC5B2a,UAAWnX,EAAQmX,WAAS,MAAa,GACzCC,QAASpX,EAAQoX,SAAO,MAAa,GACrCC,MAAOrX,EAAQqX,OAAS,CAAA,EACxBC,WAAYtX,EAAQsX,YAAc,oBAClCC,cAAuC,IAAzBvX,EAAQuX,cAIxBjd,KAAKkF,OAAS,IAAIgY,EAGlBld,KAAKmd,eACLnd,KAAKod,sBAMC,YAAAD,GACNnd,KAAKqd,OAASV,SAASW,cAAc,UACrCtd,KAAKqd,OAAO1c,KAAO,SACnBX,KAAKqd,OAAOE,UAAY,qBAGxBvd,KAAKwd,cAGLxd,KAAKyd,sBAGLzd,KAAKwc,UAAUkB,YAAY1d,KAAKqd,QAM1B,WAAAG,GACN,MAYMT,EAAQ,CAXZY,MAAO,OACPC,OAAQ,OACRC,gBAAiB,UACjBC,MAAO,UACPC,aAAc,MACdC,WAAY,oEACZC,SAAU,OACVC,QAAS,SACTC,OAAQ,WAG0Bne,KAAK0F,QAAQqX,OAGjD/R,OAAOC,OAAOjL,KAAKqd,OAAON,MAAO,CAC/BY,MAAOZ,EAAMY,MACbC,OAAQb,EAAMa,OACdC,gBAAiBd,EAAMc,gBACvBC,MAAOf,EAAMe,MACbC,aAAchB,EAAMgB,aACpBC,WAAYjB,EAAMiB,WAClBC,SAAUlB,EAAMkB,SAChBC,QAASnB,EAAMmB,QACfC,OAAQpB,EAAMoB,OACdC,OAAQ,OACRC,OAAQ,UACRC,QAAS,OACTC,WAAY,SACZC,eAAgB,SAChBC,IAAK,MACLC,WAAY,gBACZC,eAAgB,OAChBC,WAAY,MACZC,WAAY,IACZC,QAAS,OACTC,SAAU,WACVC,SAAU,WAIRjC,EAAMQ,YACRvd,KAAKqd,OAAOE,WAAa,IAAIR,EAAMQ,aAIrCvd,KAAKqd,OAAOha,iBAAiB,aAAc,KACpCrD,KAAKyc,YACRzc,KAAKqd,OAAON,MAAMkC,UAAY,mBAC9Bjf,KAAKqd,OAAON,MAAMmC,UAAY,yCAIlClf,KAAKqd,OAAOha,iBAAiB,aAAc,KACpCrD,KAAKyc,YACRzc,KAAKqd,OAAON,MAAMkC,UAAY,gBAC9Bjf,KAAKqd,OAAON,MAAMmC,UAAY,UAQ5B,mBAAAzB,GACN,GAAIzd,KAAKyc,UACPzc,KAAKqd,OAAO8B,UAAY,iVAWnB,CACL,MAAMC,EAAOpf,KAAK0F,QAAQuX,aACxB,2CAA6C,GAE/Cjd,KAAKqd,OAAO8B,UAAY,aACpBC,oBACMpf,KAAK0F,QAAQsX,4BAKzB,IAAKL,SAASC,cAAc,wBAAyB,CACnD,MAAMG,EAAQJ,SAASW,cAAc,SACrCP,EAAMxY,GAAK,sBACXwY,EAAMsC,YAAc,gJAMpB1C,SAAS2C,KAAK5B,YAAYX,IAOtB,mBAAAK,GACNpd,KAAKqd,OAAOha,iBAAiB,QAASrD,KAAKuf,YAAY1M,KAAK7S,OAG5DA,KAAKkF,OAAO2D,GAAI7F,IACK,UAAfA,EAAMrC,MAAqBX,KAAKkF,OAAOoF,oBACzCtK,KAAKwf,gBAQH,iBAAMD,GACZ,IAAIvf,KAAKyc,UAIT,IACEzc,KAAKyf,YAAW,GAGhB,MAAM1d,EAAY/B,KAAK0F,QAAQ3D,WAAa/B,KAAKyK,oBAG3CtJ,QAAiBnB,KAAKkF,OAAOpD,aAAa,CAC9CC,YACAE,iBAAkBjC,KAAK0F,QAAQzD,iBAC/BC,QAASlC,KAAK0F,QAAQxD,QACtBK,OAAQpC,OAAOqC,SAASD,SAGtBpB,EAASC,QACXpB,KAAK0F,QAAQmX,UAAU1b,GAEvBnB,KAAK0F,QAAQoX,QAAQ,IAAI5b,MAAMC,EAASL,OAAS,0BAGnD,MAAOA,GACPd,KAAK0F,QAAQoX,QAAQhc,aAAiBI,MAAQJ,EAAQ,IAAII,MAAM,kCAEhElB,KAAKyf,YAAW,IAOZ,UAAAA,CAAWC,GACjB1f,KAAKyc,UAAYiD,EACjB1f,KAAKqd,OAAOsC,SAAWD,EACvB1f,KAAKyd,sBAEDiC,GACF1f,KAAKqd,OAAON,MAAMkC,UAAY,gBAC9Bjf,KAAKqd,OAAON,MAAMmC,UAAY,OAC9Blf,KAAKqd,OAAON,MAAMsB,OAAS,QAE3Bre,KAAKqd,OAAON,MAAMsB,OAAS,UAOvB,WAAAmB,SACN,MAAMI,EAAiBjD,SAASW,cAAc,OAC9CsC,EAAerC,UAAY,eAC3BqC,EAAe7C,MAAM8C,QAAU,mNAQI,QAAlBzf,EAAAJ,KAAK0F,QAAQqX,aAAK,IAAA3c,OAAA,EAAAA,EAAE4d,aAAc,mBAEnD4B,EAAeT,UAAY,wOAO3Bnf,KAAKwc,UAAUkB,YAAYkC,GAG3B9c,WAAW,KACL8c,EAAeE,eACjBF,EAAeE,cAAcC,YAAYH,IAE1C,KAMG,iBAAAnV,GACN,MAAMS,EAAQ,IAAIvD,WAAW,IAE7B,OADAwD,OAAOC,gBAAgBF,GAChBhD,MAAMC,KAAK+C,EAAO9C,GAAQA,EAAKhE,SAAS,IAAIiE,SAAS,EAAG,MAAMC,KAAK,IAMrE,aAAA0X,CAAcC,GACnBjV,OAAOC,OAAOjL,KAAK0F,QAASua,GAC5BjgB,KAAKwd,cACLxd,KAAKyd,sBAMA,OAAAyC,GACDlgB,KAAKqd,QAAUrd,KAAKqd,OAAOyC,eAC7B9f,KAAKqd,OAAOyC,cAAcC,YAAY/f,KAAKqd,QAE7Crd,KAAKkF,OAAOnE,aAMP,SAAAof,GACL,OAAOngB,KAAKkF,eCpRHkb,GAAoD,EAC/Dre,YACAE,mBAAmB,YACnBC,UAAU,IACV2a,YACAC,UACAC,QAAQ,CAAA,EACRC,aAAa,oBACbC,gBAAe,EACfM,YAAY,GACZoC,YAAW,EACXU,cACGC,MAEH,MAAMC,EAAYC,EAAAA,OAA0B,OACrC/D,EAAWgE,GAAgBC,EAAAA,UAAS,IACpC9c,EAAS+c,GAAcD,EAAAA,UAAS,IAChCpW,EAAoBsW,GAAyBF,EAAAA,UAAS,IACtDlB,EAAaqB,GAAkBH,EAAAA,UAAS,GAG/CI,EAAAA,UAAU,KACRP,EAAUQ,QAAU,IAAI7D,EAExB,MAAM9T,EAAcmX,EAAUQ,QAAQlY,GAAI7F,IACxC,OAAQA,EAAMrC,MACZ,IAAK,QACHggB,GAAW,GACX,MACF,IAAK,sBACHC,GAAsB,GACtB,MACF,IAAK,yBACHA,GAAsB,GACtBC,GAAe,MAKrB,MAAO,KACLzX,IACImX,EAAUQ,SACZR,EAAUQ,QAAQhgB,eAGrB,IAGH+f,EAAAA,UAAU,KACR,GAAIld,GAAW2c,EAAUQ,QAAS,CAChC,MAAM7d,EAAYqd,EAAUQ,QAAQzW,mBACpCsW,EAAsB1d,GACjBA,IACH2d,GAAe,GAEf/d,WAAW,IAAM+d,GAAe,GAAQ,QAG3C,CAACjd,IAEJ,MAAM2b,EAAcyB,EAAAA,YAAYnR,UAC9B,GAAK0Q,EAAUQ,UAAWtE,IAAakD,EAIvC,IACEc,GAAa,GAGb,MAAMQ,EAAgBlf,GAAa0I,IAG7BtJ,QAAiBof,EAAUQ,QAAQjf,aAAa,CACpDC,UAAWkf,EACXhf,mBACAC,UACAK,OAAQpC,OAAOqC,SAASD,SAGtBpB,EAASC,QACXyb,SAAAA,EAAY1b,GAEZ2b,SAAAA,EAAU,IAAI5b,MAAMC,EAASL,OAAS,0BAGxC,MAAOA,GACPgc,SAAAA,EAAUhc,aAAiBI,MAAQJ,EAAQ,IAAII,MAAM,kCAErDuf,GAAa,KAEd,CAAC1e,EAAWE,EAAkBC,EAAS2a,EAAWC,EAASL,EAAWkD,IAEnElV,EAAoB,KACxB,MAAMS,EAAQ,IAAIvD,WAAW,IAE7B,OADAwD,OAAOC,gBAAgBF,GAChBhD,MAAMC,KAAK+C,EAAO9C,GAAQA,EAAKhE,SAAS,IAAIiE,SAAS,EAAG,MAAMC,KAAK,KAGtE4Y,EAAoC,CACxCvD,MAAO,OACPC,OAAQ,OACRC,gBAAiB,UACjBC,MAAO,UACPC,aAAc,MACdC,WAAY,oEACZC,SAAU,OACVC,QAAS,SACTC,OAAQ,QACRC,OAAQ,OACRC,OAAQ5B,GAAakD,EAAW,cAAgB,UAChDrB,QAAS,OACTC,WAAY,SACZC,eAAgB,SAChBC,IAAK,MACLC,WAAY,gBACZC,eAAgB,OAChBC,WAAY,MACZC,WAAY,IACZC,QAAS,OACTC,SAAU,WACVC,SAAU,SACVmC,QAASxB,EAAW,GAAM,KACvB5C,GAGCqE,EAAgBf,GACpBgB,EAAAA,KAAAC,EAAAA,SAAA,CAAAjB,SAAA,CACGpD,GAAgBsE,EAAAA,IAAA,OAAA,CAAMxE,MAAO,CAAEkB,SAAU,QAAQoC,SAAA,OAClDkB,EAAAA,IAAA,OAAA,CAAAlB,SAAO5D,EAAY,oBAAsBO,IACxCP,GACC8E,EAAAA,IAAA,MAAA,CACExE,MAAO,CACLY,MAAO,OACPC,OAAQ,OACRQ,OAAQ,wBACRoD,UAAW,yBACXzD,aAAc,MACd0D,UAAW,gCAOrB,OACEJ,EAAAA,KAAA,MAAA,CAAAhB,SAAA,CACEkB,EAAAA,IAAA,SAAA,CACE5gB,KAAK,SACL+gB,QAASnC,EACTI,SAAUA,GAAYlD,IAAc7Y,EACpC2Z,UAAW,sBAAsBA,IACjCR,MAAOmE,KACHZ,EAAKD,SAERe,IAGF5B,GACC6B,EAAAA,KAAA,MAAA,CACEtE,MAAO,CACL4E,WAAY,UACZvD,OAAQ,oBACRN,MAAO,UACPI,QAAS,WACTH,aAAc,MACdE,SAAU,OACV2D,UAAW,MACX5D,WAAYkD,EAAalD,YAC1BqC,SAAA,CAAA,0CAEuC,IACxCkB,EAAAA,IAAA,IAAA,CACE9G,KAAK,4BACLoH,OAAO,SACPC,IAAI,sBACJ/E,MAAO,CAAEe,MAAO,UAAWa,eAAgB,aAAa0B,SAAA,sBAGrD,IAAG,6BAKZkB,EAAAA,IAAA,QAAA,CAAOQ,KAAG,EAAA1B,SAAE,iJC1JZ,SAAU2B,GAAQtc,EAA0B,IAChD,MAAMuc,SAAEA,GAAW,KAASniB,GAAW4F,EAEjC6a,EAAYC,EAAAA,OAA0B,OACrC5c,EAAS+c,GAAcD,EAAAA,UAAS,IAChCpW,EAAoBsW,GAAyBF,EAAAA,UAAS,IACtDjE,EAAWgE,GAAgBC,EAAAA,UAAS,IACpC5f,EAAOohB,GAAYxB,EAAAA,SAAuB,OAC1Crf,EAAY8gB,GAAiBzB,EAAAA,SAAyB,IAG7DI,EAAAA,UAAU,KACR,IAAKmB,EAAU,OAEf,MAoCM1a,EApCasI,WACjB,IACE4Q,GAAa,GACbyB,EAAS,MAET3B,EAAUQ,QAAU,IAAI7D,EAAWpd,GAsBnC,OAnBoBygB,EAAUQ,QAAQlY,GAAI7F,UACxC,OAAQA,EAAMrC,MACZ,IAAK,QACHggB,GAAW,GACXC,GAAuC,QAAjBxgB,EAAAmgB,EAAUQ,eAAO,IAAA3gB,OAAA,EAAAA,EAAEkK,sBAAsB,GAC/D,MACF,IAAK,sBACHsW,GAAsB,GACtB,MACF,IAAK,yBACHA,GAAsB,GACtB,MACF,IAAK,QACHsB,EAASlf,EAAMoH,SAQrB,MAAOoR,GACP0G,EAAS1G,aAAeta,MAAQsa,EAAM,IAAIta,MAAM,sCAEhDuf,GAAa,KAID2B,GAEhB,MAAO,KACL7a,EAAQ1D,KAAKuF,GAAeA,aAAW,EAAXA,KACxBmX,EAAUQ,UACZR,EAAUQ,QAAQhgB,aAClBwf,EAAUQ,QAAU,QAGvB,CAACkB,EAAUniB,IAGdghB,EAAAA,UAAU,KACJld,GAAW0G,GACb+X,KAED,CAACze,EAAS0G,IAEb,MAAMxI,EAAekf,EAAAA,YAAYnR,MAAOpO,EAA0C,CAAA,KAChF,IAAK8e,EAAUQ,QACb,MAAM,IAAI7f,MAAM,+BAGlBuf,GAAa,GACbyB,EAAS,MAET,IAEE,aADuB3B,EAAUQ,QAAQjf,aAAaL,GAEtD,MAAO+Z,GACP,MAAM1a,EAAQ0a,aAAeta,MAAQsa,EAAM,IAAIta,MAAM,yBAErD,OADAghB,EAASphB,GACF,CACLM,SAAS,EACTN,MAAOA,EAAMsB,iBAGfqe,GAAa,KAEd,IAEGjf,EAAiBwf,cAAYnR,MAAOpO,IACxC,IAAK8e,EAAUQ,QACb,MAAM,IAAI7f,MAAM,+BAGlBuf,GAAa,GACbyB,EAAS,MAET,IACE,MAAMrgB,QAAiB0e,EAAUQ,QAAQvf,eAAeC,GAKxD,aAFM4gB,IAECxgB,EACP,MAAO2Z,GACP,MAAM1a,EAAQ0a,aAAeta,MAAQsa,EAAM,IAAIta,MAAM,6BAErD,MADAghB,EAASphB,GACHA,UAEN2f,GAAa,KAEd,IAEG4B,EAAoBrB,EAAAA,YAAYnR,UACpC,GAAK0Q,EAAUQ,SAAYzW,EAK3B,IACE,MAAMgY,QAAqB/B,EAAUQ,QAAQ9f,gBAC7CkhB,EAAcG,GACd,MAAO9G,GACPjS,QAAQlE,KAAK,gCAAiCmW,GAC9C2G,EAAc,SATdA,EAAc,KAWf,CAAC7X,IAEEK,EAAYqW,EAAAA,YAAYnR,SACvB0Q,EAAUQ,cASFR,EAAUQ,QAAQpW,YARtB,CACLN,OAAO,EACPC,oBAAoB,EACpBM,cAAe,EACfC,QAAS,SAKZ,IAEG0X,EAAavB,EAAAA,YAAY,KAC7BkB,EAAS,OACR,IAEH,MAAO,CACLhd,OAAQqb,EAAUQ,QAClBnd,UACA0G,qBACAmS,YACA3b,QACAO,aACAS,eACAN,iBACA6gB,oBACA1X,YACA4X,aAEJ,CC3JA,IAAAC,GAAetF,qGCvCb,WAAArd,CAAYC,EAAqB2iB,GAC/BziB,KAAKyiB,WAAaA,GAAc,IAAIvF,EACpCld,KAAKD,OAAS,IAAI2J,GAAO,GAUzB1J,KAAKF,OAAS,CACZ4iB,SAAU5iB,EAAO4iB,SACjBC,aAAc7iB,EAAO6iB,cAAgB,GACrCC,YAAa9iB,EAAO8iB,YACpBC,OAAQ/iB,EAAO+iB,QAAU,CAAC,SAAU,WACpCC,SAAU,CAXVC,sBAAuB,mBACvBC,cAAe,eACfC,iBAAkB,kBAClBC,aAAc,iBAQqBpjB,EAAOgjB,WAOvC,eAAAK,CAAgBzd,EAInB,IACF,MAAM0d,MAAEA,EAAKC,MAAEA,EAAKC,iBAAEA,EAAmB,CAAA,GAAO5d,EAE1C6d,EAAS,IAAIC,gBAAgB,CACjCC,cAAe,OACfC,UAAW1jB,KAAKF,OAAO4iB,SACvBiB,aAAc3jB,KAAKF,OAAO8iB,YAC1BgB,MAAO5jB,KAAKF,OAAO+iB,OAAOva,KAAK,QAC5Bgb,IAGDF,GACFG,EAAOnS,IAAI,QAASgS,GAGlBC,GACFE,EAAOnS,IAAI,QAASiS,GAItBE,EAAOnS,IAAI,eAAgB,QAC3BmS,EAAOnS,IAAI,gBAAiB,SAG5B,MAAO,GADSpR,KAAKF,OAAOgjB,SAASC,yBAChBQ,EAAOnf,aAMvB,oBAAMyf,CAAeC,GAI1B,MAAMxJ,EAAM,IAAI/R,IAAIub,GACdzY,EAAOiP,EAAIyJ,aAAate,IAAI,QAC5B2d,EAAQ9I,EAAIyJ,aAAate,IAAI,SAC7B3E,EAAQwZ,EAAIyJ,aAAate,IAAI,SAEnC,GAAI3E,EACF,MAAM,IAAII,MAAM,gBAAgBJ,OAAWwZ,EAAIyJ,aAAate,IAAI,wBAGlE,IAAK4F,EACH,MAAM,IAAInK,MAAM,kCAGlBlB,KAAKD,OAAOQ,MAAM,uCAAwC8K,GAG1D,MAAM2Y,QAAehkB,KAAKikB,sBAAsB5Y,EAAM+X,GAGtD,IAAIc,EAKJ,OAJIlkB,KAAKF,OAAO+iB,OAAOvU,SAAS,YAActO,KAAKF,OAAOgjB,SAASG,mBACjEiB,QAAiBlkB,KAAKmkB,YAAYH,EAAOI,cAGpC,CAAEJ,SAAQE,YAMX,2BAAMD,CAAsB5Y,EAAc+X,GAChD,IAEE,MAAMiB,QAAqBrkB,KAAKyiB,WAAW3gB,aAAa,CACtDC,UAAW/B,KAAKyK,oBAChBlI,OAAQpC,OAAOqC,SAASD,SAG1B,IAAK8hB,EAAajjB,QAChB,MAAM,IAAIF,MAAM,iDAIlB,MAAMojB,EAAe,CACnBC,WAAY,qBACZb,UAAW1jB,KAAKF,OAAO4iB,SACvB8B,cAAexkB,KAAKF,OAAO6iB,aAC3BtX,OACAsY,aAAc3jB,KAAKF,OAAO8iB,YAC1B6B,gBAAiB7Q,KAAKiF,UAAUwL,EAAaliB,aAGzChB,QAAiB+a,MAAMlc,KAAKF,OAAOgjB,SAASE,cAAe,CAC/D0B,OAAQ,OACR7Q,QAAS,CACP,eAAgB,oCAChB8Q,OAAU,oBAEZC,KAAM,IAAIpB,gBAAgBc,GAAclgB,aAG1C,IAAKjD,EAAS0jB,GAAI,CAChB,MAAMC,QAAkB3jB,EAASkb,OAAOvY,MAAM,KAAA,CAAS,IACvD,MAAM,IAAI5C,MAAM,0BAA0B4jB,EAAUhkB,OAASK,EAAS4jB,cAGxE,MAAMC,QAAkB7jB,EAASkb,OAIjC,OAFArc,KAAKD,OAAOQ,MAAM,6BAEX,CACL6jB,YAAaY,EAAUC,aACvBC,UAAWF,EAAUG,YAAc,SACnCC,UAAWJ,EAAUK,WACrBC,aAAcN,EAAUO,cACxB3B,MAAOoB,EAAUpB,MACjB4B,QAASR,EAAUS,UAGrB,MAAO3kB,GAEP,MADAd,KAAKD,OAAOe,MAAM,yBAA0BA,GACtCA,GAOH,kBAAMwkB,CAAaA,GACxB,IAAKA,EACH,MAAM,IAAIpkB,MAAM,6BAGlB,IAEE,MAAMmjB,QAAqBrkB,KAAKyiB,WAAW3gB,aAAa,CACtDC,UAAW/B,KAAKyK,oBAChBlI,OAAQpC,OAAOqC,SAASD,SAG1B,IAAK8hB,EAAajjB,QAChB,MAAM,IAAIF,MAAM,gDAGlB,MAAMwkB,EAAiB,CACrBnB,WAAY,gBACZb,UAAW1jB,KAAKF,OAAO4iB,SACvB8B,cAAexkB,KAAKF,OAAO6iB,aAC3B4C,cAAeD,EACfb,gBAAiB7Q,KAAKiF,UAAUwL,EAAaliB,aAGzChB,QAAiB+a,MAAMlc,KAAKF,OAAOgjB,SAASE,cAAe,CAC/D0B,OAAQ,OACR7Q,QAAS,CACP,eAAgB,oCAChB8Q,OAAU,oBAEZC,KAAM,IAAIpB,gBAAgBkC,GAAgBthB,aAG5C,IAAKjD,EAAS0jB,GAAI,CAChB,MAAMC,QAAkB3jB,EAASkb,OAAOvY,MAAM,KAAA,CAAS,IACvD,MAAM,IAAI5C,MAAM,yBAAyB4jB,EAAUhkB,OAASK,EAAS4jB,cAGvE,MAAMC,QAAkB7jB,EAASkb,OAEjC,MAAO,CACL+H,YAAaY,EAAUC,aACvBC,UAAWF,EAAUG,YAAc,SACnCC,UAAWJ,EAAUK,WACrBC,aAAcN,EAAUO,eAAiBD,EACzC1B,MAAOoB,EAAUpB,MACjB4B,QAASR,EAAUS,UAGrB,MAAO3kB,GAEP,MADAd,KAAKD,OAAOe,MAAM,wBAAyBA,GACrCA,GAOH,iBAAMqjB,CAAYC,GACvB,IAAKpkB,KAAKF,OAAOgjB,SAASG,iBACxB,MAAM,IAAI/hB,MAAM,qCAGlB,IACE,MAAMC,QAAiB+a,MAAMlc,KAAKF,OAAOgjB,SAASG,iBAAkB,CAClEpP,QAAS,CACP8R,cAAiB,UAAUvB,IAC3BO,OAAU,sBAId,IAAKxjB,EAAS0jB,GACZ,MAAM,IAAI3jB,MAAM,8BAA8BC,EAAS4jB,cAGzD,aAAa5jB,EAASkb,OAEtB,MAAOvb,GAEP,MADAd,KAAKD,OAAOe,MAAM,2BAA4BA,GACxCA,GAOH,mBAAM8kB,CAAcJ,GACzB,IAAKxlB,KAAKF,OAAOgjB,SAASI,aAExB,OADAljB,KAAKD,OAAOsF,KAAK,6DC9PhB,SAAmBgT,GACtB,GAAmB,iBAARA,EACP,MAAM,IAAIlL,EAAW,iEACzB,MAAQ,EAAGR,EAAO/E,OAAEA,GAAWyQ,EAAIE,MAAM,KACzC,GAAe,IAAX3Q,EACA,MAAM,IAAIuF,EAAW,4DACzB,GAAe,IAAXvF,EACA,MAAM,IAAIuF,EAAW,eACzB,IAAKR,EACD,MAAM,IAAIQ,EAAW,+BACzB,IAAI0Y,EAOAhQ,EANJ,IACIgQ,EAAUlS,GAAUhH,EAC5B,CACI,MACI,MAAM,IAAIQ,EAAW,yCAC7B,CAEI,IACI0I,EAASjC,KAAKhE,MAAM/D,EAAQE,OAAO8Z,GAC3C,CACI,MACI,MAAM,IAAI1Y,EAAW,8CAC7B,CACI,IAAKiC,EAASyG,GACV,MAAM,IAAI1I,EAAW,0BACzB,OAAO0I,CACX,CDoOaiQ,CAAeN,GAGxB,IAEE,MAAMzM,QPhKL,SAA4BuB,EAAK5U,GACpC,MAAM0L,EAAM,IAAIiJ,GAAaC,EAAK5U,GAC5BqgB,EAAelW,MAAO6D,EAAiB2F,IAAUjI,EAAIgI,OAAO1F,EAAiB2F,GA8BnF,OA7BArO,OAAO8O,iBAAiBiM,EAAc,CAClC1K,YAAa,CACT5V,IAAK,IAAM2L,EAAIiK,cACftB,YAAY,EACZC,cAAc,GAElBsB,MAAO,CACH7V,IAAK,IAAM2L,EAAIkK,QACfvB,YAAY,EACZC,cAAc,GAElBuB,OAAQ,CACJlM,MAAO,IAAM+B,EAAImK,SACjBxB,YAAY,EACZC,cAAc,EACdC,UAAU,GAEd+L,UAAW,CACPvgB,IAAK,MAAQ2L,EAAIqK,cACjB1B,YAAY,EACZC,cAAc,GAElBjB,KAAM,CACF1J,MAAO,IAAM+B,EAAIgK,QAAQrC,OACzBgB,YAAY,EACZC,cAAc,EACdC,UAAU,KAGX8L,CACX,CO+HyBE,CAAwB,IAAI1d,IAAIvI,KAAKF,OAAOgjB,SAASI,gBAGlEvW,QAAEA,SAAkBuZ,GAAeV,EAASzM,EAAM,CACtDhC,OAAQ/W,KAAKmmB,4BACblP,SAAUjX,KAAKF,OAAO4iB,WAGxB,OAAO/V,EAEP,MAAO7L,GAEP,MADAd,KAAKD,OAAOe,MAAM,gCAAiCA,GAC7C,IAAII,MAAM,qBAOb,iBAAAklB,CAAkB1gB,EAGrB,IACF,MAAM2gB,sBAAEA,EAAqBjD,MAAEA,GAAU1d,EAGnC4gB,EAAiBtmB,KAAKF,OAAOgjB,SAASC,sBAAsB7W,QAAQ,aAAc,WAElFqX,EAAS,IAAIC,gBAAgB,CACjCE,UAAW1jB,KAAKF,OAAO4iB,WAWzB,OARI2D,GACF9C,EAAOnS,IAAI,2BAA4BiV,GAGrCjD,GACFG,EAAOnS,IAAI,QAASgS,GAGf,GAAGkD,KAAkB/C,EAAOnf,aAM9B,qBAAAmiB,GAEL,MAAMrb,EAAQ,IAAIvD,WAAW,IAC7BwD,OAAOC,gBAAgBF,GACvB,MAAMsb,EAAexmB,KAAKymB,gBAAgBvb,GAIpCd,GADU,IAAIpC,aACCC,OAAOue,GAC5B,OAAOrb,OAAOqF,OAAOkW,OAAO,UAAWtc,GAAMvG,KAAKiK,IAChD,MAAM6Y,EAAgB3mB,KAAKymB,gBAAgB,IAAI9e,WAAWmG,IAC1D,MAAO,CAAE0Y,eAAcG,mBAOpB,qBAAMC,CAAgBlhB,EAGzB,IACF,MAAM0d,MAAEA,EAAKC,MAAEA,GAAU3d,GAGnB8gB,aAAEA,EAAYG,cAAEA,GAAkB3mB,KAAKumB,wBAY7C,MAAO,CAAEM,QATO7mB,KAAKmjB,gBAAgB,CACnCC,QACAC,QACAC,iBAAkB,CAChBwD,eAAgBH,EAChBI,sBAAuB,UAITP,gBAGZ,iBAAA/b,GACN,MAAMS,EAAQ,IAAIvD,WAAW,IAE7B,OADAwD,OAAOC,gBAAgBF,GAChBhD,MAAMC,KAAK+C,EAAO9C,GAAQA,EAAKhE,SAAS,IAAIiE,SAAS,EAAG,MAAMC,KAAK,IAGpE,eAAAme,CAAgB1e,GAEtB,OADeif,KAAKC,OAAOC,gBAAgBnf,IAC7BmE,QAAQ,MAAO,KAAKA,QAAQ,MAAO,KAAKA,QAAQ,KAAM,IAG9D,yBAAAia,GACN,IACE,MAAM7L,EAAM,IAAI/R,IAAIvI,KAAKF,OAAOgjB,SAASC,uBACzC,MAAO,GAAGzI,EAAI6M,aAAa7M,EAAI8M,OAC/B,MAAAhnB,GACA,MAAO,WAOJ,YAAA0K,CAAaC,GAClBC,OAAOC,OAAOjL,KAAKF,OAAQiL,GAMtB,SAAAsc,GACL,MAAO,IAAKrnB,KAAKF,qIJzEf,SAA6B0c,EAAiC9W,GAClE,OAAO,IAAI0a,GAAiB5D,EAAW9W,EACzC","x_google_ignoreList":[5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,40]}