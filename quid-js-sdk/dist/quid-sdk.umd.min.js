/*!
 * QuID JavaScript SDK v1.0.0
 * https://docs.quid.dev/sdk/javascript
 * 
 * Copyright 2025 QuID Team
 * Licensed under MIT
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("react/jsx-runtime"),require("react")):"function"==typeof define&&define.amd?define(["exports","react/jsx-runtime","react"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).QuIDSDK={},e.jsxRuntime,e.React)}(this,function(e,t,n){"use strict";class r{constructor(e,t){this.isConnected=!1,this.config=e,this.logger=t}async connect(){var e;try{if("undefined"==typeof window||!(null===(e=window.chrome)||void 0===e?void 0:e.runtime))return this.logger.debug("Not in browser environment or Chrome APIs not available"),!1;if(!await this.detectExtension())return this.logger.debug("QuID extension not detected"),!1;const t=await this.sendMessage({type:"GET_EXTENSION_STATUS"});return!(!t||void 0===t.isConnected)&&(this.isConnected=!0,this.logger.info("Successfully connected to QuID extension"),!0)}catch(e){return this.logger.debug("Failed to connect to extension:",e),!1}}disconnect(){this.isConnected=!1,this.extensionId=void 0}async getIdentities(){if(!this.isConnected)throw new Error("Extension not connected");try{const e=await this.sendMessage({type:"GET_IDENTITIES"});if(e.success&&e.identities)return e.identities.map(this.mapIdentity);throw new Error(e.error||"Failed to get identities")}catch(e){throw this.logger.error("Failed to get identities from extension:",e),e}}async createIdentity(e){if(!this.isConnected)throw new Error("Extension not connected");try{const t=await this.sendMessage({type:"CREATE_IDENTITY",config:{name:e.name,securityLevel:e.securityLevel||"Level1",networks:e.networks||["web"]}});if(t.success&&t.identity)return this.mapIdentity(t.identity);throw new Error(t.error||"Failed to create identity")}catch(e){throw this.logger.error("Failed to create identity via extension:",e),e}}async authenticate(e){if(!this.isConnected)throw new Error("Extension not connected");try{const t=await this.sendMessage({type:"AUTH_REQUEST",challenge:e.challenge,allowCredentials:e.allowCredentials,userVerification:e.userVerification,timeout:e.timeout});return{success:t.success||!1,error:t.error,credential:t.credential,identity:t.identity?this.mapIdentity(t.identity):void 0}}catch(e){return this.logger.error("Authentication via extension failed:",e),{success:!1,error:e instanceof Error?e.message:"Authentication failed"}}}async signChallenge(e,t){if(!this.isConnected)throw new Error("Extension not connected");try{const n=await this.sendMessage({type:"SIGN_CHALLENGE",identityId:e,challenge:t,origin:window.location.origin});if(n.success&&n.signature)return n.signature;throw new Error(n.error||"Failed to sign challenge")}catch(e){throw this.logger.error("Failed to sign challenge via extension:",e),e}}async detectExtension(){try{return window.QuID&&window.QuID.isAvailable?(this.logger.debug("QuID API detected in page"),!0):new Promise(e=>{const t=setTimeout(()=>e(!1),1e3),n=r=>{r.detail&&r.detail.available&&(clearTimeout(t),window.removeEventListener("quid:ready",n),e(!0))};window.addEventListener("quid:ready",n),window.dispatchEvent(new CustomEvent("quid:detect"))})}catch(e){return this.logger.debug("Extension detection failed:",e),!1}}async sendMessage(e){return new Promise((t,n)=>{var r;const i=setTimeout(()=>{n(new Error("Extension message timeout"))},this.config.timeout||6e4);try{if(this.extensionId&&(null===(r=window.chrome)||void 0===r?void 0:r.runtime))return void window.chrome.runtime.sendMessage(this.extensionId,e,e=>{clearTimeout(i),window.chrome.runtime.lastError?n(new Error(window.chrome.runtime.lastError.message)):t(e)});if(window.QuID)return void this.handleQuIDAPIMessage(e,t,n,i);this.handleCustomEventMessage(e,t,n,i)}catch(e){clearTimeout(i),n(e)}})}handleQuIDAPIMessage(e,t,n,r){try{switch(e.type){case"GET_EXTENSION_STATUS":window.QuID.isReady().then(t).catch(n);break;case"GET_IDENTITIES":window.QuID.getIdentities().then(t).catch(n);break;case"AUTH_REQUEST":window.QuID.authenticate({challenge:e.challenge,userVerification:e.userVerification,timeout:e.timeout,allowCredentials:e.allowCredentials}).then(t).catch(n);break;case"CREATE_IDENTITY":window.QuID.createIdentity(e.config).then(t).catch(n);break;case"SIGN_CHALLENGE":window.QuID.signChallenge(e.identityId,e.challenge).then(e=>t({success:!0,signature:e})).catch(n);break;default:n(new Error("Unknown message type"))}}catch(e){clearTimeout(r),n(e)}}handleCustomEventMessage(e,t,n,r){const i=`quid-${Date.now()}-${Math.random().toString(36).substr(2,9)}`,o=e=>{e.detail&&e.detail.requestId===i&&(clearTimeout(r),window.removeEventListener("quid:response",o),t(e.detail.response))};window.addEventListener("quid:response",o),window.dispatchEvent(new CustomEvent("quid:request",{detail:{...e,requestId:i}}))}mapIdentity(e){return{id:e.id,name:e.name,securityLevel:e.security_level||e.securityLevel||"Level1",networks:e.networks||["web"],isActive:!1!==e.is_active,createdAt:new Date(e.created_at||e.createdAt||Date.now()),lastUsedAt:e.last_used_at||e.lastUsedAt?new Date(e.last_used_at||e.lastUsedAt):void 0,publicKey:e.public_key||e.publicKey}}}class i{constructor(e,t){this.client=e,this.logger=t}init(){this.isWebAuthnSupported()?this.logger.debug("WebAuthn bridge initialized"):this.logger.warn("WebAuthn is not supported in this browser")}isWebAuthnSupported(){return!!(navigator.credentials&&navigator.credentials.create&&navigator.credentials.get)}async authenticate(e){if(!this.isWebAuthnSupported())return{success:!1,error:"WebAuthn is not supported in this browser"};try{this.logger.debug("Starting WebAuthn fallback authentication");const t={publicKey:{challenge:this.stringToArrayBuffer(e.challenge),timeout:e.timeout,rpId:e.rpId||this.extractDomain(e.origin),allowCredentials:e.allowCredentials||[],userVerification:e.userVerification||"preferred"}},n=await navigator.credentials.get(t);if(!n)return{success:!1,error:"No credential returned from WebAuthn"};const r=n.response,i={id:n.id,rawId:this.arrayBufferToString(n.rawId),type:"public-key",response:{authenticatorData:this.arrayBufferToString(r.authenticatorData),clientDataJSON:this.arrayBufferToString(r.clientDataJSON),signature:this.arrayBufferToString(r.signature),userHandle:r.userHandle?this.arrayBufferToString(r.userHandle):void 0}};return this.logger.info("WebAuthn fallback authentication successful"),{success:!0,credential:i}}catch(e){return this.logger.error("WebAuthn fallback authentication failed:",e),{success:!1,error:this.getWebAuthnErrorMessage(e)}}}async createCredential(e){if(!this.isWebAuthnSupported())return{success:!1,error:"WebAuthn is not supported in this browser"};try{this.logger.debug("Creating WebAuthn credential");const t={publicKey:{challenge:this.stringToArrayBuffer(e.challenge),rp:{name:e.rpName,id:e.rpId||this.extractDomain(window.location.origin)},user:{id:this.stringToArrayBuffer(e.userId),name:e.userName,displayName:e.userDisplayName},pubKeyCredParams:[{alg:-7,type:"public-key"},{alg:-257,type:"public-key"}],timeout:e.timeout||6e4,authenticatorSelection:{authenticatorAttachment:"platform",userVerification:"preferred",requireResidentKey:!1},attestation:"direct"}},n=await navigator.credentials.create(t);if(!n)return{success:!1,error:"No credential created"};const r=n.response,i={id:n.id,rawId:this.arrayBufferToString(n.rawId),type:"public-key",response:{authenticatorData:this.arrayBufferToString(r.authenticatorData),clientDataJSON:this.arrayBufferToString(r.clientDataJSON),signature:"",userHandle:void 0}};return this.logger.info("WebAuthn credential created successfully"),{success:!0,credential:i}}catch(e){return this.logger.error("WebAuthn credential creation failed:",e),{success:!1,error:this.getWebAuthnErrorMessage(e)}}}async isCredentialAvailable(){if(!this.isWebAuthnSupported())return!1;try{return await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()}catch(e){return this.logger.debug("Could not check credential availability:",e),!1}}cleanup(){this.logger.debug("WebAuthn bridge cleaned up")}stringToArrayBuffer(e){if(/^[0-9a-fA-F]+$/.test(e)){const t=new Uint8Array(e.length/2);for(let n=0;n<e.length;n+=2)t[n/2]=parseInt(e.substr(n,2),16);return t.buffer}return(new TextEncoder).encode(e).buffer}arrayBufferToString(e){const t=new Uint8Array(e);return Array.from(t,e=>e.toString(16).padStart(2,"0")).join("")}extractDomain(e){try{return new URL(e).hostname}catch(t){return this.logger.warn("Could not extract domain from origin:",e),"localhost"}}getWebAuthnErrorMessage(e){if(!e)return"Unknown WebAuthn error";const t=e.name||"",n=e.message||"";switch(t){case"NotAllowedError":return"Authentication was cancelled or not allowed";case"SecurityError":return"Security error during authentication";case"NotSupportedError":return"WebAuthn is not supported on this device";case"InvalidStateError":return"Invalid state for WebAuthn operation";case"ConstraintError":return"WebAuthn constraints could not be satisfied";case"UnknownError":return"An unknown error occurred during authentication";default:return n||"WebAuthn authentication failed"}}}class o{constructor(){this.listeners=[]}on(e){return this.listeners.push(e),()=>{const t=this.listeners.indexOf(e);t>-1&&this.listeners.splice(t,1)}}once(e){const t=this.on(n=>{e(n),t()});return t}emit(e){const t=[...this.listeners];for(const n of t)try{n(e)}catch(e){console.error("Error in event listener:",e)}}removeAllListeners(){this.listeners=[]}get listenerCount(){return this.listeners.length}}class s{constructor(e=!1){this.prefix="[QuID SDK]",this.debug=e}setDebug(e){this.debug=e}debug(e,...t){this.debug&&console.debug(this.prefix,e,...t)}info(e,...t){this.debug&&console.info(this.prefix,e,...t)}warn(e,...t){console.warn(this.prefix,e,...t)}error(e,...t){console.error(this.prefix,e,...t)}}let a=class extends o{constructor(e={}){super(),this.isReady=!1,this.config={baseUrl:"",timeout:6e4,userVerification:"preferred",debug:!1,extensionId:"",enableWebAuthnFallback:!0,...e},this.logger=new s(this.config.debug),this.extensionConnector=new r(this.config,this.logger),this.webauthnBridge=new i(this,this.logger),this.init()}async init(){try{this.logger.debug("Initializing QuID client...");await this.extensionConnector.connect()?(this.logger.info("Connected to QuID browser extension"),this.emit({type:"extension-connected",timestamp:new Date})):(this.logger.warn("QuID browser extension not available"),this.config.enableWebAuthnFallback&&this.logger.info("WebAuthn fallback enabled")),this.webauthnBridge.init(),this.isReady=!0,this.emit({type:"ready",timestamp:new Date}),this.logger.info("QuID client ready")}catch(e){this.logger.error("Failed to initialize QuID client:",e),this.emit({type:"error",data:e,timestamp:new Date})}}get ready(){return this.isReady}get extensionAvailable(){return this.extensionConnector.isConnected}async getIdentities(){if(!this.isReady)throw this.createError("SDK_NOT_READY","QuID SDK is not ready");try{return this.extensionConnector.isConnected?await this.extensionConnector.getIdentities():(this.logger.warn("No extension available, returning empty identity list"),[])}catch(e){throw this.logger.error("Failed to get identities:",e),this.createError("GET_IDENTITIES_FAILED","Failed to retrieve identities",e)}}async createIdentity(e){if(!this.isReady)throw this.createError("SDK_NOT_READY","QuID SDK is not ready");if(!this.extensionConnector.isConnected)throw this.createError("EXTENSION_NOT_AVAILABLE","QuID browser extension is required for identity creation");try{this.logger.debug("Creating new identity:",e);const t=await this.extensionConnector.createIdentity(e);return this.emit({type:"identity-created",data:t,timestamp:new Date}),this.logger.info("Identity created successfully:",t.id),t}catch(e){throw this.logger.error("Failed to create identity:",e),this.createError("CREATE_IDENTITY_FAILED","Failed to create identity",e)}}async authenticate(e={}){if(!this.isReady)throw this.createError("SDK_NOT_READY","QuID SDK is not ready");const t={challenge:e.challenge||this.generateChallenge(),origin:e.origin||window.location.origin,userVerification:e.userVerification||this.config.userVerification,timeout:e.timeout||this.config.timeout,allowCredentials:e.allowCredentials,rpId:e.rpId};this.emit({type:"authentication-started",data:t,timestamp:new Date});try{let e;if(this.logger.debug("Starting authentication:",t),this.extensionConnector.isConnected)e=await this.extensionConnector.authenticate(t);else{if(!this.config.enableWebAuthnFallback||!navigator.credentials)throw this.createError("NO_AUTH_METHOD","No authentication method available");this.logger.info("Using WebAuthn fallback"),e=await this.webauthnBridge.authenticate(t)}return e.success?(this.emit({type:"authentication-completed",data:e,timestamp:new Date}),this.logger.info("Authentication successful")):(this.emit({type:"authentication-failed",data:e,timestamp:new Date}),this.logger.warn("Authentication failed:",e.error)),e}catch(e){this.logger.error("Authentication error:",e);const t={success:!1,error:e instanceof Error?e.message:"Unknown authentication error"};return this.emit({type:"authentication-failed",data:t,timestamp:new Date}),t}}async signChallenge(e,t){if(!this.isReady)throw this.createError("SDK_NOT_READY","QuID SDK is not ready");if(!this.extensionConnector.isConnected)throw this.createError("EXTENSION_NOT_AVAILABLE","QuID browser extension is required for signing");try{this.logger.debug("Signing challenge:",{identityId:e,challenge:t});const n=await this.extensionConnector.signChallenge(e,t);return this.logger.info("Challenge signed successfully"),n}catch(e){throw this.logger.error("Failed to sign challenge:",e),this.createError("SIGN_CHALLENGE_FAILED","Failed to sign challenge",e)}}async getStatus(){const e=this.extensionAvailable?await this.getIdentities():[];return{ready:this.isReady,extensionAvailable:this.extensionAvailable,identityCount:e.length,version:"1.0.0"}}updateConfig(e){Object.assign(this.config,e),this.logger.setDebug(this.config.debug),this.logger.debug("Configuration updated:",e)}disconnect(){this.logger.debug("Disconnecting QuID client"),this.extensionConnector.disconnect(),this.webauthnBridge.cleanup(),this.isReady=!1,this.emit({type:"extension-disconnected",timestamp:new Date})}generateChallenge(){const e=new Uint8Array(32);return crypto.getRandomValues(e),Array.from(e,e=>e.toString(16).padStart(2,"0")).join("")}createError(e,t,n){const r=new Error(t);return r.name="QuIDSDKError",r.code=e,r.details=n,r}};var c=crypto;const d=e=>e instanceof CryptoKey,l=new TextEncoder,u=new TextDecoder;const h=e=>{let t=e;t instanceof Uint8Array&&(t=u.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return(e=>{const t=atob(e),n=new Uint8Array(t.length);for(let e=0;e<t.length;e++)n[e]=t.charCodeAt(e);return n})(t)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}};class f extends Error{constructor(e,t){super(e,t),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,Error.captureStackTrace?.(this,this.constructor)}}f.code="ERR_JOSE_GENERIC";class g extends f{constructor(e,t,n="unspecified",r="unspecified"){super(e,{cause:{claim:n,reason:r,payload:t}}),this.code="ERR_JWT_CLAIM_VALIDATION_FAILED",this.claim=n,this.reason=r,this.payload=t}}g.code="ERR_JWT_CLAIM_VALIDATION_FAILED";class p extends f{constructor(e,t,n="unspecified",r="unspecified"){super(e,{cause:{claim:n,reason:r,payload:t}}),this.code="ERR_JWT_EXPIRED",this.claim=n,this.reason=r,this.payload=t}}p.code="ERR_JWT_EXPIRED";class y extends f{constructor(){super(...arguments),this.code="ERR_JOSE_ALG_NOT_ALLOWED"}}y.code="ERR_JOSE_ALG_NOT_ALLOWED";class w extends f{constructor(){super(...arguments),this.code="ERR_JOSE_NOT_SUPPORTED"}}w.code="ERR_JOSE_NOT_SUPPORTED";(class extends f{constructor(e="decryption operation failed",t){super(e,t),this.code="ERR_JWE_DECRYPTION_FAILED"}}).code="ERR_JWE_DECRYPTION_FAILED";(class extends f{constructor(){super(...arguments),this.code="ERR_JWE_INVALID"}}).code="ERR_JWE_INVALID";class m extends f{constructor(){super(...arguments),this.code="ERR_JWS_INVALID"}}m.code="ERR_JWS_INVALID";class b extends f{constructor(){super(...arguments),this.code="ERR_JWT_INVALID"}}b.code="ERR_JWT_INVALID";(class extends f{constructor(){super(...arguments),this.code="ERR_JWK_INVALID"}}).code="ERR_JWK_INVALID";class E extends f{constructor(){super(...arguments),this.code="ERR_JWKS_INVALID"}}E.code="ERR_JWKS_INVALID";class S extends f{constructor(e="no applicable key found in the JSON Web Key Set",t){super(e,t),this.code="ERR_JWKS_NO_MATCHING_KEY"}}S.code="ERR_JWKS_NO_MATCHING_KEY";class v extends f{constructor(e="multiple matching keys found in the JSON Web Key Set",t){super(e,t),this.code="ERR_JWKS_MULTIPLE_MATCHING_KEYS"}}v.code="ERR_JWKS_MULTIPLE_MATCHING_KEYS";class A extends f{constructor(e="request timed out",t){super(e,t),this.code="ERR_JWKS_TIMEOUT"}}A.code="ERR_JWKS_TIMEOUT";class k extends f{constructor(e="signature verification failed",t){super(e,t),this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}function _(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function I(e,t){return e.name===t}function T(e){return parseInt(e.name.slice(4),10)}function x(e,t,...n){switch(t){case"HS256":case"HS384":case"HS512":{if(!I(e.algorithm,"HMAC"))throw _("HMAC");const n=parseInt(t.slice(2),10);if(T(e.algorithm.hash)!==n)throw _(`SHA-${n}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!I(e.algorithm,"RSASSA-PKCS1-v1_5"))throw _("RSASSA-PKCS1-v1_5");const n=parseInt(t.slice(2),10);if(T(e.algorithm.hash)!==n)throw _(`SHA-${n}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!I(e.algorithm,"RSA-PSS"))throw _("RSA-PSS");const n=parseInt(t.slice(2),10);if(T(e.algorithm.hash)!==n)throw _(`SHA-${n}`,"algorithm.hash");break}case"EdDSA":if("Ed25519"!==e.algorithm.name&&"Ed448"!==e.algorithm.name)throw _("Ed25519 or Ed448");break;case"Ed25519":if(!I(e.algorithm,"Ed25519"))throw _("Ed25519");break;case"ES256":case"ES384":case"ES512":{if(!I(e.algorithm,"ECDSA"))throw _("ECDSA");const n=function(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}(t);if(e.algorithm.namedCurve!==n)throw _(n,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}!function(e,t){if(t.length&&!t.some(t=>e.usages.includes(t))){let e="CryptoKey does not support this operation, its usages must include ";if(t.length>2){const n=t.pop();e+=`one of ${t.join(", ")}, or ${n}.`}else 2===t.length?e+=`one of ${t[0]} or ${t[1]}.`:e+=`${t[0]}.`;throw new TypeError(e)}}(e,n)}function C(e,t,...n){if((n=n.filter(Boolean)).length>2){const t=n.pop();e+=`one of type ${n.join(", ")}, or ${t}.`}else 2===n.length?e+=`one of type ${n[0]} or ${n[1]}.`:e+=`of type ${n[0]}.`;return null==t?e+=` Received ${t}`:"function"==typeof t&&t.name?e+=` Received function ${t.name}`:"object"==typeof t&&null!=t&&t.constructor?.name&&(e+=` Received an instance of ${t.constructor.name}`),e}k.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED";var D=(e,...t)=>C("Key must be ",e,...t);function R(e,t,...n){return C(`Key for the ${e} algorithm must be `,t,...n)}var W=e=>!!d(e)||"KeyObject"===e?.[Symbol.toStringTag];const O=["CryptoKey"];function N(e){if("object"!=typeof(t=e)||null===t||"[object Object]"!==Object.prototype.toString.call(e))return!1;var t;if(null===Object.getPrototypeOf(e))return!0;let n=e;for(;null!==Object.getPrototypeOf(n);)n=Object.getPrototypeOf(n);return Object.getPrototypeOf(e)===n}function P(e){return N(e)&&"string"==typeof e.kty}const K=async e=>{if(!e.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');const{algorithm:t,keyUsages:n}=function(e){let t,n;switch(e.kty){case"RSA":switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},n=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},n=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},n=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new w('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"EC":switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},n=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},n=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},n=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},n=e.d?["deriveBits"]:[];break;default:throw new w('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"OKP":switch(e.alg){case"Ed25519":t={name:"Ed25519"},n=e.d?["sign"]:["verify"];break;case"EdDSA":t={name:e.crv},n=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv},n=e.d?["deriveBits"]:[];break;default:throw new w('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;default:throw new w('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:n}}(e),r=[t,e.ext??!1,e.key_ops??n],i={...e};return delete i.alg,delete i.use,c.subtle.importKey("jwk",i,...r)},J=e=>h(e);let L;const j=e=>"KeyObject"===e?.[Symbol.toStringTag],U=async(e,t,n,r,i=!1)=>{let o=e.get(t);if(o?.[r])return o[r];const s=await K({...n,alg:r});return i&&Object.freeze(t),o?o[r]=s:e.set(t,{[r]:s}),s};var H=(e,t)=>{if(j(e)){let n=e.export({format:"jwk"});return delete n.d,delete n.dp,delete n.dq,delete n.p,delete n.q,delete n.qi,n.k?J(n.k):(L||(L=new WeakMap),U(L,e,n,t))}if(P(e)){if(e.k)return h(e.k);L||(L=new WeakMap);return U(L,e,e,t,!0)}return e};async function F(e,t){if(!N(e))throw new TypeError("JWK must be an object");switch(t||(t=e.alg),e.kty){case"oct":if("string"!=typeof e.k||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');return h(e.k);case"RSA":if("oth"in e&&void 0!==e.oth)throw new w('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return K({...e,alg:t});default:throw new w('Unsupported "kty" (Key Type) Parameter value')}}const $=e=>e?.[Symbol.toStringTag],M=(e,t,n)=>{if(void 0!==t.use&&"sig"!==t.use)throw new TypeError("Invalid key for this operation, when present its use must be sig");if(void 0!==t.key_ops&&!0!==t.key_ops.includes?.(n))throw new TypeError(`Invalid key for this operation, when present its key_ops must include ${n}`);if(void 0!==t.alg&&t.alg!==e)throw new TypeError(`Invalid key for this operation, when present its alg must be ${e}`);return!0},Q=(e,t,n,r)=>{if(!(t instanceof Uint8Array)){if(r&&P(t)){if(function(e){return P(e)&&"oct"===e.kty&&"string"==typeof e.k}(t)&&M(e,t,n))return;throw new TypeError('JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present')}if(!W(t))throw new TypeError(R(e,t,...O,"Uint8Array",r?"JSON Web Key":null));if("secret"!==t.type)throw new TypeError(`${$(t)} instances for symmetric algorithms must be of type "secret"`)}};function q(e,t,n,r){t.startsWith("HS")||"dir"===t||t.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(t)?Q(t,n,r,e):((e,t,n,r)=>{if(r&&P(t))switch(n){case"sign":if(function(e){return"oct"!==e.kty&&"string"==typeof e.d}(t)&&M(e,t,n))return;throw new TypeError("JSON Web Key for this operation be a private JWK");case"verify":if(function(e){return"oct"!==e.kty&&void 0===e.d}(t)&&M(e,t,n))return;throw new TypeError("JSON Web Key for this operation be a public JWK")}if(!W(t))throw new TypeError(R(e,t,...O,r?"JSON Web Key":null));if("secret"===t.type)throw new TypeError(`${$(t)} instances for asymmetric algorithms must not be of type "secret"`);if("sign"===n&&"public"===t.type)throw new TypeError(`${$(t)} instances for asymmetric algorithm signing must be of type "private"`);if("decrypt"===n&&"public"===t.type)throw new TypeError(`${$(t)} instances for asymmetric algorithm decryption must be of type "private"`);if(t.algorithm&&"verify"===n&&"private"===t.type)throw new TypeError(`${$(t)} instances for asymmetric algorithm verifying must be of type "public"`);if(t.algorithm&&"encrypt"===n&&"private"===t.type)throw new TypeError(`${$(t)} instances for asymmetric algorithm encryption must be of type "public"`)})(t,n,r,e)}q.bind(void 0,!1);const B=q.bind(void 0,!0);const V=async(e,t,n,r)=>{const i=await async function(e,t,n){if(t=await H(t,e),d(t))return x(t,e,n),t;if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(D(t,...O));return c.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},!1,[n])}throw new TypeError(D(t,...O,"Uint8Array","JSON Web Key"))}(e,t,"verify");((e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:n}=t.algorithm;if("number"!=typeof n||n<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}})(e,i);const o=function(e,t){const n=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:n,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:n,name:"RSA-PSS",saltLength:e.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash:n,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:n,name:"ECDSA",namedCurve:t.namedCurve};case"Ed25519":return{name:"Ed25519"};case"EdDSA":return{name:t.name};default:throw new w(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}(e,i.algorithm);try{return await c.subtle.verify(o,i,n,r)}catch{return!1}};async function z(e,t,n){if(!N(e))throw new m("Flattened JWS must be an object");if(void 0===e.protected&&void 0===e.header)throw new m('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==e.protected&&"string"!=typeof e.protected)throw new m("JWS Protected Header incorrect type");if(void 0===e.payload)throw new m("JWS Payload missing");if("string"!=typeof e.signature)throw new m("JWS Signature missing or incorrect type");if(void 0!==e.header&&!N(e.header))throw new m("JWS Unprotected Header incorrect type");let r={};if(e.protected)try{const t=h(e.protected);r=JSON.parse(u.decode(t))}catch{throw new m("JWS Protected Header is invalid")}if(!((...e)=>{const t=e.filter(Boolean);if(0===t.length||1===t.length)return!0;let n;for(const e of t){const t=Object.keys(e);if(n&&0!==n.size)for(const e of t){if(n.has(e))return!1;n.add(e)}else n=new Set(t)}return!0})(r,e.header))throw new m("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const i={...r,...e.header},o=function(e,t,n,r,i){if(void 0!==i.crit&&void 0===r?.crit)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!r||void 0===r.crit)return new Set;if(!Array.isArray(r.crit)||0===r.crit.length||r.crit.some(e=>"string"!=typeof e||0===e.length))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let o;o=void 0!==n?new Map([...Object.entries(n),...t.entries()]):t;for(const t of r.crit){if(!o.has(t))throw new w(`Extension Header Parameter "${t}" is not recognized`);if(void 0===i[t])throw new e(`Extension Header Parameter "${t}" is missing`);if(o.get(t)&&void 0===r[t])throw new e(`Extension Header Parameter "${t}" MUST be integrity protected`)}return new Set(r.crit)}(m,new Map([["b64",!0]]),n?.crit,r,i);let s=!0;if(o.has("b64")&&(s=r.b64,"boolean"!=typeof s))throw new m('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:a}=i;if("string"!=typeof a||!a)throw new m('JWS "alg" (Algorithm) Header Parameter missing or invalid');const c=n&&((e,t)=>{if(void 0!==t&&(!Array.isArray(t)||t.some(e=>"string"!=typeof e)))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)})("algorithms",n.algorithms);if(c&&!c.has(a))throw new y('"alg" (Algorithm) Header Parameter value not allowed');if(s){if("string"!=typeof e.payload)throw new m("JWS Payload must be a string")}else if("string"!=typeof e.payload&&!(e.payload instanceof Uint8Array))throw new m("JWS Payload must be a string or an Uint8Array instance");let d=!1;"function"==typeof t?(t=await t(r,e),d=!0,B(a,t,"verify"),P(t)&&(t=await F(t,a))):B(a,t,"verify");const f=function(...e){const t=e.reduce((e,{length:t})=>e+t,0),n=new Uint8Array(t);let r=0;for(const t of e)n.set(t,r),r+=t.length;return n}(l.encode(e.protected??""),l.encode("."),"string"==typeof e.payload?l.encode(e.payload):e.payload);let g;try{g=h(e.signature)}catch{throw new m("Failed to base64url decode the signature")}if(!await V(a,t,g,f))throw new k;let p;if(s)try{p=h(e.payload)}catch{throw new m("Failed to base64url decode the payload")}else p="string"==typeof e.payload?l.encode(e.payload):e.payload;const b={payload:p};return void 0!==e.protected&&(b.protectedHeader=r),void 0!==e.header&&(b.unprotectedHeader=e.header),d?{...b,key:t}:b}const G=86400,Y=/^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;var X=e=>{const t=Y.exec(e);if(!t||t[4]&&t[1])throw new TypeError("Invalid time period format");const n=parseFloat(t[2]);let r;switch(t[3].toLowerCase()){case"sec":case"secs":case"second":case"seconds":case"s":r=Math.round(n);break;case"minute":case"minutes":case"min":case"mins":case"m":r=Math.round(60*n);break;case"hour":case"hours":case"hr":case"hrs":case"h":r=Math.round(3600*n);break;case"day":case"days":case"d":r=Math.round(n*G);break;case"week":case"weeks":case"w":r=Math.round(604800*n);break;default:r=Math.round(31557600*n)}return"-"===t[1]||"ago"===t[4]?-r:r};const Z=e=>e.toLowerCase().replace(/^application\//,"");var ee=(e,t,n={})=>{let r;try{r=JSON.parse(u.decode(t))}catch{}if(!N(r))throw new b("JWT Claims Set must be a top-level JSON object");const{typ:i}=n;if(i&&("string"!=typeof e.typ||Z(e.typ)!==Z(i)))throw new g('unexpected "typ" JWT header value',r,"typ","check_failed");const{requiredClaims:o=[],issuer:s,subject:a,audience:c,maxTokenAge:d}=n,l=[...o];void 0!==d&&l.push("iat"),void 0!==c&&l.push("aud"),void 0!==a&&l.push("sub"),void 0!==s&&l.push("iss");for(const e of new Set(l.reverse()))if(!(e in r))throw new g(`missing required "${e}" claim`,r,e,"missing");if(s&&!(Array.isArray(s)?s:[s]).includes(r.iss))throw new g('unexpected "iss" claim value',r,"iss","check_failed");if(a&&r.sub!==a)throw new g('unexpected "sub" claim value',r,"sub","check_failed");if(c&&(h=r.aud,f="string"==typeof c?[c]:c,!("string"==typeof h?f.includes(h):Array.isArray(h)&&f.some(Set.prototype.has.bind(new Set(h))))))throw new g('unexpected "aud" claim value',r,"aud","check_failed");var h,f;let y;switch(typeof n.clockTolerance){case"string":y=X(n.clockTolerance);break;case"number":y=n.clockTolerance;break;case"undefined":y=0;break;default:throw new TypeError("Invalid clockTolerance option type")}const{currentDate:w}=n,m=(E=w||new Date,Math.floor(E.getTime()/1e3));var E;if((void 0!==r.iat||d)&&"number"!=typeof r.iat)throw new g('"iat" claim must be a number',r,"iat","invalid");if(void 0!==r.nbf){if("number"!=typeof r.nbf)throw new g('"nbf" claim must be a number',r,"nbf","invalid");if(r.nbf>m+y)throw new g('"nbf" claim timestamp check failed',r,"nbf","check_failed")}if(void 0!==r.exp){if("number"!=typeof r.exp)throw new g('"exp" claim must be a number',r,"exp","invalid");if(r.exp<=m-y)throw new p('"exp" claim timestamp check failed',r,"exp","check_failed")}if(d){const e=m-r.iat;if(e-y>("number"==typeof d?d:X(d)))throw new p('"iat" claim timestamp check failed (too far in the past)',r,"iat","check_failed");if(e<0-y)throw new g('"iat" claim timestamp check failed (it should be in the past)',r,"iat","check_failed")}return r};async function te(e,t,n){const r=await async function(e,t,n){if(e instanceof Uint8Array&&(e=u.decode(e)),"string"!=typeof e)throw new m("Compact JWS must be a string or Uint8Array");const{0:r,1:i,2:o,length:s}=e.split(".");if(3!==s)throw new m("Invalid Compact JWS");const a=await z({payload:i,protected:r,signature:o},t,n),c={payload:a.payload,protectedHeader:a.protectedHeader};return"function"==typeof t?{...c,key:a.key}:c}(e,t,n);if(r.protectedHeader.crit?.includes("b64")&&!1===r.protectedHeader.b64)throw new b("JWTs MUST NOT use unencoded payload");const i={payload:ee(r.protectedHeader,r.payload,n),protectedHeader:r.protectedHeader};return"function"==typeof t?{...i,key:r.key}:i}function ne(e){return N(e)}function re(e){return"function"==typeof structuredClone?structuredClone(e):JSON.parse(JSON.stringify(e))}class ie{constructor(e){if(this._cached=new WeakMap,!function(e){return e&&"object"==typeof e&&Array.isArray(e.keys)&&e.keys.every(ne)}(e))throw new E("JSON Web Key Set malformed");this._jwks=re(e)}async getKey(e,t){const{alg:n,kid:r}={...e,...t?.header},i=function(e){switch("string"==typeof e&&e.slice(0,2)){case"RS":case"PS":return"RSA";case"ES":return"EC";case"Ed":return"OKP";default:throw new w('Unsupported "alg" value for a JSON Web Key Set')}}(n),o=this._jwks.keys.filter(e=>{let t=i===e.kty;if(t&&"string"==typeof r&&(t=r===e.kid),t&&"string"==typeof e.alg&&(t=n===e.alg),t&&"string"==typeof e.use&&(t="sig"===e.use),t&&Array.isArray(e.key_ops)&&(t=e.key_ops.includes("verify")),t)switch(n){case"ES256":t="P-256"===e.crv;break;case"ES256K":t="secp256k1"===e.crv;break;case"ES384":t="P-384"===e.crv;break;case"ES512":t="P-521"===e.crv;break;case"Ed25519":t="Ed25519"===e.crv;break;case"EdDSA":t="Ed25519"===e.crv||"Ed448"===e.crv}return t}),{0:s,length:a}=o;if(0===a)throw new S;if(1!==a){const e=new v,{_cached:t}=this;throw e[Symbol.asyncIterator]=async function*(){for(const e of o)try{yield await oe(t,e,n)}catch{}},e}return oe(this._cached,s,n)}}async function oe(e,t,n){const r=e.get(t)||e.set(t,{}).get(t);if(void 0===r[n]){const e=await F({...t,ext:!0},n);if(e instanceof Uint8Array||"public"!==e.type)throw new E("JSON Web Key Set members must be public keys");r[n]=e}return r[n]}function se(e){const t=new ie(e),n=async(e,n)=>t.getKey(e,n);return Object.defineProperties(n,{jwks:{value:()=>re(t._jwks),enumerable:!0,configurable:!1,writable:!1}}),n}let ae;if("undefined"==typeof navigator||!navigator.userAgent?.startsWith?.("Mozilla/5.0 ")){ae=`${"jose"}/${"v5.10.0"}`}const ce=Symbol();class de{constructor(e,t){if(!(e instanceof URL))throw new TypeError("url must be an instance of URL");var n,r;this._url=new URL(e.href),this._options={agent:t?.agent,headers:t?.headers},this._timeoutDuration="number"==typeof t?.timeoutDuration?t?.timeoutDuration:5e3,this._cooldownDuration="number"==typeof t?.cooldownDuration?t?.cooldownDuration:3e4,this._cacheMaxAge="number"==typeof t?.cacheMaxAge?t?.cacheMaxAge:6e5,void 0!==t?.[ce]&&(this._cache=t?.[ce],n=t?.[ce],r=this._cacheMaxAge,"object"==typeof n&&null!==n&&"uat"in n&&"number"==typeof n.uat&&!(Date.now()-n.uat>=r)&&"jwks"in n&&N(n.jwks)&&Array.isArray(n.jwks.keys)&&Array.prototype.every.call(n.jwks.keys,N)&&(this._jwksTimestamp=this._cache.uat,this._local=se(this._cache.jwks)))}coolingDown(){return"number"==typeof this._jwksTimestamp&&Date.now()<this._jwksTimestamp+this._cooldownDuration}fresh(){return"number"==typeof this._jwksTimestamp&&Date.now()<this._jwksTimestamp+this._cacheMaxAge}async getKey(e,t){this._local&&this.fresh()||await this.reload();try{return await this._local(e,t)}catch(n){if(n instanceof S&&!1===this.coolingDown())return await this.reload(),this._local(e,t);throw n}}async reload(){this._pendingFetch&&("undefined"!=typeof WebSocketPair||"undefined"!=typeof navigator&&"Cloudflare-Workers"===navigator.userAgent||"undefined"!=typeof EdgeRuntime&&"vercel"===EdgeRuntime)&&(this._pendingFetch=void 0);const e=new Headers(this._options.headers);ae&&!e.has("User-Agent")&&(e.set("User-Agent",ae),this._options.headers=Object.fromEntries(e.entries())),this._pendingFetch||(this._pendingFetch=(async(e,t,n)=>{let r,i,o=!1;"function"==typeof AbortController&&(r=new AbortController,i=setTimeout(()=>{o=!0,r.abort()},t));const s=await fetch(e.href,{signal:r?r.signal:void 0,redirect:"manual",headers:n.headers}).catch(e=>{if(o)throw new A;throw e});if(void 0!==i&&clearTimeout(i),200!==s.status)throw new f("Expected 200 OK from the JSON Web Key Set HTTP response");try{return await s.json()}catch{throw new f("Failed to parse the JSON Web Key Set HTTP response as JSON")}})(this._url,this._timeoutDuration,this._options).then(e=>{this._local=se(e),this._cache&&(this._cache.uat=Date.now(),this._cache.jwks=e),this._jwksTimestamp=Date.now(),this._pendingFetch=void 0}).catch(e=>{throw this._pendingFetch=void 0,e})),await this._pendingFetch}}const le=h;let ue=class{constructor(e,t={}){if(this.isLoading=!1,"string"==typeof e){const t=document.querySelector(e);if(!t)throw new Error(`Container element not found: ${e}`);this.container=t}else this.container=e;this.options={challenge:t.challenge||"",userVerification:t.userVerification||"preferred",timeout:t.timeout||6e4,onSuccess:t.onSuccess||(()=>{}),onError:t.onError||(()=>{}),style:t.style||{},buttonText:t.buttonText||"Sign in with QuID",showBranding:!1!==t.showBranding},this.client=new a,this.createButton(),this.setupEventListeners()}createButton(){this.button=document.createElement("button"),this.button.type="button",this.button.className="quid-signin-button",this.applyStyles(),this.updateButtonContent(),this.container.appendChild(this.button)}applyStyles(){const e={width:"100%",height:"44px",backgroundColor:"#667eea",color:"#ffffff",borderRadius:"6px",fontFamily:'-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',fontSize:"16px",padding:"0 16px",margin:"8px 0",...this.options.style};Object.assign(this.button.style,{width:e.width,height:e.height,backgroundColor:e.backgroundColor,color:e.color,borderRadius:e.borderRadius,fontFamily:e.fontFamily,fontSize:e.fontSize,padding:e.padding,margin:e.margin,border:"none",cursor:"pointer",display:"flex",alignItems:"center",justifyContent:"center",gap:"8px",transition:"all 0.2s ease",textDecoration:"none",fontWeight:"500",lineHeight:"1",outline:"none",position:"relative",overflow:"hidden"}),e.className&&(this.button.className+=` ${e.className}`),this.button.addEventListener("mouseenter",()=>{this.isLoading||(this.button.style.transform="translateY(-1px)",this.button.style.boxShadow="0 4px 12px rgba(102, 126, 234, 0.3)")}),this.button.addEventListener("mouseleave",()=>{this.isLoading||(this.button.style.transform="translateY(0)",this.button.style.boxShadow="none")})}updateButtonContent(){if(this.isLoading)this.button.innerHTML='\n        <div class="quid-spinner" style="\n          width: 16px;\n          height: 16px;\n          border: 2px solid transparent;\n          border-top: 2px solid currentColor;\n          border-radius: 50%;\n          animation: quid-spin 1s linear infinite;\n        "></div>\n        <span>Authenticating...</span>\n      ';else{const e=this.options.showBranding?'<span style="font-size: 18px;">üîê</span>':"";this.button.innerHTML=`\n        ${e}\n        <span>${this.options.buttonText}</span>\n      `}if(!document.querySelector("#quid-spinner-styles")){const e=document.createElement("style");e.id="quid-spinner-styles",e.textContent="\n        @keyframes quid-spin {\n          0% { transform: rotate(0deg); }\n          100% { transform: rotate(360deg); }\n        }\n      ",document.head.appendChild(e)}}setupEventListeners(){this.button.addEventListener("click",this.handleClick.bind(this)),this.client.on(e=>{"ready"!==e.type||this.client.extensionAvailable||this.showWarning()})}async handleClick(){if(!this.isLoading)try{this.setLoading(!0);const e=this.options.challenge||this.generateChallenge(),t=await this.client.authenticate({challenge:e,userVerification:this.options.userVerification,timeout:this.options.timeout,origin:window.location.origin});t.success?this.options.onSuccess(t):this.options.onError(new Error(t.error||"Authentication failed"))}catch(e){this.options.onError(e instanceof Error?e:new Error("Authentication failed"))}finally{this.setLoading(!1)}}setLoading(e){this.isLoading=e,this.button.disabled=e,this.updateButtonContent(),e?(this.button.style.transform="translateY(0)",this.button.style.boxShadow="none",this.button.style.cursor="wait"):this.button.style.cursor="pointer"}showWarning(){var e;const t=document.createElement("div");t.className="quid-warning",t.style.cssText=`\n      background: #fff3cd;\n      border: 1px solid #ffeaa7;\n      color: #856404;\n      padding: 8px 12px;\n      border-radius: 4px;\n      font-size: 12px;\n      margin-top: 4px;\n      font-family: ${(null===(e=this.options.style)||void 0===e?void 0:e.fontFamily)||"inherit"};\n    `,t.innerHTML='\n      ‚ö†Ô∏è QuID browser extension not detected. \n      <a href="https://quid.dev/download" target="_blank" style="color: inherit; text-decoration: underline;">\n        Install extension\n      </a> for full functionality.\n    ',this.container.appendChild(t),setTimeout(()=>{t.parentElement&&t.parentElement.removeChild(t)},1e4)}generateChallenge(){const e=new Uint8Array(32);return crypto.getRandomValues(e),Array.from(e,e=>e.toString(16).padStart(2,"0")).join("")}updateOptions(e){Object.assign(this.options,e),this.applyStyles(),this.updateButtonContent()}destroy(){this.button&&this.button.parentElement&&this.button.parentElement.removeChild(this.button),this.client.disconnect()}getClient(){return this.client}};const he=({challenge:e,userVerification:r="preferred",timeout:i=6e4,onSuccess:o,onError:s,style:c={},buttonText:d="Sign in with QuID",showBranding:l=!0,className:u="",disabled:h=!1,children:f,...g})=>{const p=n.useRef(null),[y,w]=n.useState(!1),[m,b]=n.useState(!1),[E,S]=n.useState(!1),[v,A]=n.useState(!1);n.useEffect(()=>{p.current=new a;const e=p.current.on(e=>{switch(e.type){case"ready":b(!0);break;case"extension-connected":S(!0);break;case"extension-disconnected":S(!1),A(!0)}});return()=>{e(),p.current&&p.current.disconnect()}},[]),n.useEffect(()=>{if(m&&p.current){const e=p.current.extensionAvailable;S(e),e||(A(!0),setTimeout(()=>A(!1),1e4))}},[m]);const k=n.useCallback(async()=>{if(p.current&&!y&&!h)try{w(!0);const t=e||_(),n=await p.current.authenticate({challenge:t,userVerification:r,timeout:i,origin:window.location.origin});n.success?null==o||o(n):null==s||s(new Error(n.error||"Authentication failed"))}catch(e){null==s||s(e instanceof Error?e:new Error("Authentication failed"))}finally{w(!1)}},[e,r,i,o,s,y,h]),_=()=>{const e=new Uint8Array(32);return crypto.getRandomValues(e),Array.from(e,e=>e.toString(16).padStart(2,"0")).join("")},I={width:"100%",height:"44px",backgroundColor:"#667eea",color:"#ffffff",borderRadius:"6px",fontFamily:'-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',fontSize:"16px",padding:"0 16px",margin:"8px 0",border:"none",cursor:y||h?"not-allowed":"pointer",display:"flex",alignItems:"center",justifyContent:"center",gap:"8px",transition:"all 0.2s ease",textDecoration:"none",fontWeight:"500",lineHeight:"1",outline:"none",position:"relative",overflow:"hidden",opacity:h?.6:1,...c},T=f||t.jsxs(t.Fragment,{children:[l&&t.jsx("span",{style:{fontSize:"18px"},children:"üîê"}),t.jsx("span",{children:y?"Authenticating...":d}),y&&t.jsx("div",{style:{width:"16px",height:"16px",border:"2px solid transparent",borderTop:"2px solid currentColor",borderRadius:"50%",animation:"spin 1s linear infinite"}})]});return t.jsxs("div",{children:[t.jsx("button",{type:"button",onClick:k,disabled:h||y||!m,className:`quid-signin-button ${u}`,style:I,...g,children:T}),v&&t.jsxs("div",{style:{background:"#fff3cd",border:"1px solid #ffeaa7",color:"#856404",padding:"8px 12px",borderRadius:"4px",fontSize:"12px",marginTop:"4px",fontFamily:I.fontFamily},children:["‚ö†Ô∏è QuID browser extension not detected."," ",t.jsx("a",{href:"https://quid.dev/download",target:"_blank",rel:"noopener noreferrer",style:{color:"inherit",textDecoration:"underline"},children:"Install extension"})," ","for full functionality."]}),t.jsx("style",{jsx:!0,children:"\n        @keyframes spin {\n          0% { transform: rotate(0deg); }\n          100% { transform: rotate(360deg); }\n        }\n      "})]})};function fe(e={}){const{autoInit:t=!0,...r}=e,i=n.useRef(null),[o,s]=n.useState(!1),[c,d]=n.useState(!1),[l,u]=n.useState(!1),[h,f]=n.useState(null),[g,p]=n.useState([]);n.useEffect(()=>{if(!t)return;const e=(async()=>{try{u(!0),f(null),i.current=new a(r);return i.current.on(e=>{var t;switch(e.type){case"ready":s(!0),d((null===(t=i.current)||void 0===t?void 0:t.extensionAvailable)||!1);break;case"extension-connected":d(!0);break;case"extension-disconnected":d(!1);break;case"error":f(e.data)}})}catch(e){f(e instanceof Error?e:new Error("Failed to initialize QuID"))}finally{u(!1)}})();return()=>{e.then(e=>null==e?void 0:e()),i.current&&(i.current.disconnect(),i.current=null)}},[t,r]),n.useEffect(()=>{o&&c&&m()},[o,c]);const y=n.useCallback(async(e={})=>{if(!i.current)throw new Error("QuID client not initialized");u(!0),f(null);try{return await i.current.authenticate(e)}catch(e){const t=e instanceof Error?e:new Error("Authentication failed");return f(t),{success:!1,error:t.message}}finally{u(!1)}},[]),w=n.useCallback(async e=>{if(!i.current)throw new Error("QuID client not initialized");u(!0),f(null);try{const t=await i.current.createIdentity(e);return await m(),t}catch(e){const t=e instanceof Error?e:new Error("Failed to create identity");throw f(t),t}finally{u(!1)}},[]),m=n.useCallback(async()=>{if(i.current&&c)try{const e=await i.current.getIdentities();p(e)}catch(e){console.warn("Failed to refresh identities:",e),p([])}else p([])},[c]),b=n.useCallback(async()=>i.current?await i.current.getStatus():{ready:!1,extensionAvailable:!1,identityCount:0,version:"1.0.0"},[]),E=n.useCallback(()=>{f(null)},[]);return{client:i.current,isReady:o,extensionAvailable:c,isLoading:l,error:h,identities:g,authenticate:y,createIdentity:w,refreshIdentities:m,getStatus:b,clearError:E}}var ge=QuIDClient;e.EventEmitter=o,e.ExtensionConnector=r,e.Logger=s,e.QuIDClient=a,e.QuIDOAuthClient=class{constructor(e,t){this.quidClient=t||new a,this.logger=new s(!1);this.config={clientId:e.clientId,clientSecret:e.clientSecret||"",redirectUri:e.redirectUri,scopes:e.scopes||["openid","profile"],provider:{authorizationEndpoint:"/oauth/authorize",tokenEndpoint:"/oauth/token",userInfoEndpoint:"/oauth/userinfo",jwksEndpoint:"/oauth/jwks",...e.provider}}}generateAuthUrl(e={}){const{state:t,nonce:n,additionalParams:r={}}=e,i=new URLSearchParams({response_type:"code",client_id:this.config.clientId,redirect_uri:this.config.redirectUri,scope:this.config.scopes.join(" "),...r});t&&i.set("state",t),n&&i.set("nonce",n),i.set("quid_enabled","true"),i.set("response_mode","query");return`${this.config.provider.authorizationEndpoint}?${i.toString()}`}async handleCallback(e){const t=new URL(e),n=t.searchParams.get("code"),r=t.searchParams.get("state"),i=t.searchParams.get("error");if(i)throw new Error(`OAuth error: ${i} - ${t.searchParams.get("error_description")}`);if(!n)throw new Error("No authorization code received");this.logger.debug("Processing OAuth callback with code:",n);const o=await this.exchangeCodeForTokens(n,r);let s;return this.config.scopes.includes("profile")&&this.config.provider.userInfoEndpoint&&(s=await this.getUserInfo(o.accessToken)),{tokens:o,userInfo:s}}async exchangeCodeForTokens(e,t){try{const t=await this.quidClient.authenticate({challenge:this.generateChallenge(),origin:window.location.origin});if(!t.success)throw new Error("QuID authentication failed for token exchange");const n={grant_type:"authorization_code",client_id:this.config.clientId,client_secret:this.config.clientSecret,code:e,redirect_uri:this.config.redirectUri,quid_credential:JSON.stringify(t.credential)},r=await fetch(this.config.provider.tokenEndpoint,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"},body:new URLSearchParams(n).toString()});if(!r.ok){const e=await r.json().catch(()=>({}));throw new Error(`Token exchange failed: ${e.error||r.statusText}`)}const i=await r.json();return this.logger.debug("Token exchange successful"),{accessToken:i.access_token,tokenType:i.token_type||"Bearer",expiresIn:i.expires_in,refreshToken:i.refresh_token,scope:i.scope,idToken:i.id_token}}catch(e){throw this.logger.error("Token exchange failed:",e),e}}async refreshToken(e){if(!e)throw new Error("Refresh token is required");try{const t=await this.quidClient.authenticate({challenge:this.generateChallenge(),origin:window.location.origin});if(!t.success)throw new Error("QuID authentication failed for token refresh");const n={grant_type:"refresh_token",client_id:this.config.clientId,client_secret:this.config.clientSecret,refresh_token:e,quid_credential:JSON.stringify(t.credential)},r=await fetch(this.config.provider.tokenEndpoint,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"},body:new URLSearchParams(n).toString()});if(!r.ok){const e=await r.json().catch(()=>({}));throw new Error(`Token refresh failed: ${e.error||r.statusText}`)}const i=await r.json();return{accessToken:i.access_token,tokenType:i.token_type||"Bearer",expiresIn:i.expires_in,refreshToken:i.refresh_token||e,scope:i.scope,idToken:i.id_token}}catch(e){throw this.logger.error("Token refresh failed:",e),e}}async getUserInfo(e){if(!this.config.provider.userInfoEndpoint)throw new Error("User info endpoint not configured");try{const t=await fetch(this.config.provider.userInfoEndpoint,{headers:{Authorization:`Bearer ${e}`,Accept:"application/json"}});if(!t.ok)throw new Error(`Failed to fetch user info: ${t.statusText}`);return await t.json()}catch(e){throw this.logger.error("Failed to get user info:",e),e}}async verifyIdToken(e){if(!this.config.provider.jwksEndpoint)return this.logger.warn("JWKS endpoint not configured, skipping token verification"),function(e){if("string"!=typeof e)throw new b("JWTs must use Compact JWS serialization, JWT must be a string");const{1:t,length:n}=e.split(".");if(5===n)throw new b("Only JWTs using Compact JWS serialization can be decoded");if(3!==n)throw new b("Invalid JWT");if(!t)throw new b("JWTs must contain a payload");let r,i;try{r=le(t)}catch{throw new b("Failed to base64url decode the payload")}try{i=JSON.parse(u.decode(r))}catch{throw new b("Failed to parse the decoded payload as JSON")}if(!N(i))throw new b("Invalid JWT Claims Set");return i}(e);try{const t=await function(e,t){const n=new de(e,t),r=async(e,t)=>n.getKey(e,t);return Object.defineProperties(r,{coolingDown:{get:()=>n.coolingDown(),enumerable:!0,configurable:!1},fresh:{get:()=>n.fresh(),enumerable:!0,configurable:!1},reload:{value:()=>n.reload(),enumerable:!0,configurable:!1,writable:!1},reloading:{get:()=>!!n._pendingFetch,enumerable:!0,configurable:!1},jwks:{value:()=>n._local?.jwks(),enumerable:!0,configurable:!1,writable:!1}}),r}(new URL(this.config.provider.jwksEndpoint)),{payload:n}=await te(e,t,{issuer:this.extractIssuerFromEndpoint(),audience:this.config.clientId});return n}catch(e){throw this.logger.error("ID token verification failed:",e),new Error("Invalid ID token")}}generateLogoutUrl(e={}){const{postLogoutRedirectUri:t,state:n}=e,r=this.config.provider.authorizationEndpoint.replace("/authorize","/logout"),i=new URLSearchParams({client_id:this.config.clientId});return t&&i.set("post_logout_redirect_uri",t),n&&i.set("state",n),`${r}?${i.toString()}`}generatePKCEChallenge(){const e=new Uint8Array(32);crypto.getRandomValues(e);const t=this.base64URLEncode(e),n=(new TextEncoder).encode(t);return crypto.subtle.digest("SHA-256",n).then(e=>{const n=this.base64URLEncode(new Uint8Array(e));return{codeVerifier:t,codeChallenge:n}})}async startSecureFlow(e={}){const{state:t,nonce:n}=e,{codeVerifier:r,codeChallenge:i}=this.generatePKCEChallenge();return{authUrl:this.generateAuthUrl({state:t,nonce:n,additionalParams:{code_challenge:i,code_challenge_method:"S256"}}),codeVerifier:r}}generateChallenge(){const e=new Uint8Array(32);return crypto.getRandomValues(e),Array.from(e,e=>e.toString(16).padStart(2,"0")).join("")}base64URLEncode(e){return btoa(String.fromCharCode(...e)).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}extractIssuerFromEndpoint(){try{const e=new URL(this.config.provider.authorizationEndpoint);return`${e.protocol}//${e.host}`}catch(e){return"unknown"}}updateConfig(e){Object.assign(this.config,e)}getConfig(){return{...this.config}}},e.QuIDSigninButton=ue,e.QuIDSigninButtonReact=he,e.QuIDSigninButtonReactDefault=he,e.WebAuthnBridge=i,e.createSigninButton=function(e,t){return new ue(e,t)},e.default=ge,e.useQuID=fe,e.useQuIDDefault=fe,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=quid-sdk.umd.min.js.map
